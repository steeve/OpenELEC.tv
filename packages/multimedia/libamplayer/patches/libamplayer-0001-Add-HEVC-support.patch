From 0a622ae653e6ec34cc4712a015df744493b2890e Mon Sep 17 00:00:00 2001
From: Stanislav Vlasic <svlasic@gmail.com>
Date: Fri, 9 Jan 2015 12:00:46 +0100
Subject: [PATCH 1/4] Add HEVC support

---
 amcodec/codec/codec_ctrl.c           |    7 +-
 amcodec/codec/codec_h_ctrl.h         |    1 +
 amcodec/include/amports/vformat.h    |    5 +-
 amffmpeg/config.h                    |    2 +
 amffmpeg/config.mak                  |    2 +
 amffmpeg/libavcodec/Makefile         |    1 +
 amffmpeg/libavcodec/allcodecs.c      |    1 +
 amffmpeg/libavcodec/avcodec.h        |    7 +
 amffmpeg/libavcodec/hevc.c           | 1900 ++++++++++++++++++++++++++++++++++
 amffmpeg/libavcodec/hevc.h           |  977 +++++++++++++++++
 amffmpeg/libavcodec/hevc_parser.c    |  362 +++++++
 amffmpeg/libavformat/Makefile        |    1 +
 amffmpeg/libavformat/allformats.c    |    1 +
 amffmpeg/libavformat/avformat.h      |    4 +
 amffmpeg/libavformat/hevcdec.c       |   90 ++
 amplayer/player/player_av.c          |   26 +-
 amplayer/player/player_ctrl.c        |    5 +-
 amplayer/player/player_ffmpeg_ctrl.c |   25 +-
 18 files changed, 3410 insertions(+), 7 deletions(-)
 create mode 100644 amffmpeg/libavcodec/hevc.c
 create mode 100644 amffmpeg/libavcodec/hevc.h
 create mode 100644 amffmpeg/libavcodec/hevc_parser.c
 create mode 100644 amffmpeg/libavformat/hevcdec.c

diff --git a/amcodec/codec/codec_ctrl.c b/amcodec/codec/codec_ctrl.c
index cd9ce99..9de57c4 100755
--- a/amcodec/codec/codec_ctrl.c
+++ b/amcodec/codec/codec_ctrl.c
@@ -278,7 +278,12 @@ static inline int codec_video_es_init(codec_para_t *pcodec)
     }
 
     flags |= pcodec->noblock ? O_NONBLOCK : 0;
-    handle = codec_h_open(CODEC_VIDEO_ES_DEVICE, flags);
+    if(pcodec->am_sysinfo.format == VIDEO_DEC_FORMAT_HEVC) {
+      handle = codec_h_open(CODEC_VIDEO_ES_HEVC_DEVICE, flags);
+    }
+    else {
+      handle = codec_h_open(CODEC_VIDEO_ES_DEVICE, flags);
+    }
     if (handle < 0) {
         codec_r = system_error_to_codec_error(handle);
         print_error_msg(codec_r, errno, __FUNCTION__, __LINE__);
diff --git a/amcodec/codec/codec_h_ctrl.h b/amcodec/codec/codec_h_ctrl.h
index 652843c..55d905d 100755
--- a/amcodec/codec/codec_h_ctrl.h
+++ b/amcodec/codec/codec_h_ctrl.h
@@ -41,6 +41,7 @@
 #define CODEC_SUB_DEVICE            "/dev/amstream_sub"
 #define CODEC_SUB_READ_DEVICE       "/dev/amstream_sub_read"
 #define CODEC_AUDIO_UTILS_DEVICE    "/dev/amaudio_utils"
+#define CODEC_VIDEO_ES_HEVC_DEVICE  "/dev/amstream_hevc"
 
 CODEC_HANDLE codec_h_open(const char *port_addr, int flags);
 int codec_h_close(CODEC_HANDLE h);
diff --git a/amcodec/include/amports/vformat.h b/amcodec/include/amports/vformat.h
index d88e6fa..a86a0a5 100755
--- a/amcodec/include/amports/vformat.h
+++ b/amcodec/include/amports/vformat.h
@@ -40,6 +40,7 @@ typedef enum {
     VIDEO_DEC_FORMAT_MPEG4_4,
     VIDEO_DEC_FORMAT_MPEG4_5,
     VIDEO_DEC_FORMAT_H264,
+    VIDEO_DEC_FORMAT_HEVC,
     VIDEO_DEC_FORMAT_MJPEG,
     VIDEO_DEC_FORMAT_MP4,
     VIDEO_DEC_FORMAT_H263,
@@ -66,6 +67,7 @@ typedef enum {
     VFORMAT_SW,
     VFORMAT_H264MVC,
     VFORMAT_H264_4K2K,
+    VFORMAT_HEVC,
     VFORMAT_UNSUPPORT,
     VFORMAT_MAX
 } vformat_t;
@@ -87,7 +89,7 @@ typedef enum {
 #define CODEC_TAG_MP43      (0x3334504d)
 #define CODEC_TAG_M4S2      (0x3253344d)
 #define CODEC_TAG_DIV4      (0x34564944)
-#define CODEC_TAG_divx       (0x78766964)
+#define CODEC_TAG_divx      (0x78766964)
 #define CODEC_TAG_DIVX      (0x58564944)
 #define CODEC_TAG_DIV5      (0x35564944)
 #define CODEC_TAG_3IV2      (0x32564933)
@@ -101,6 +103,7 @@ typedef enum {
 #define CODEC_TAG_mp4v      (0x7634706d)
 #define CODEC_TAG_AVC1      (0x31435641)
 #define CODEC_TAG_avc1      (0x31637661)
+#define CODEC_TAG_hvc1      (0x31637668)
 #define CODEC_TAG_H264      (0x34363248)
 #define CODEC_TAG_h264      (0x34363268)
 #define CODEC_TAG_H263      (0x33363248)
diff --git a/amffmpeg/config.h b/amffmpeg/config.h
index afb82b5..3fa1cb0 100755
--- a/amffmpeg/config.h
+++ b/amffmpeg/config.h
@@ -678,6 +678,7 @@
 #define CONFIG_H261_PARSER 1
 #define CONFIG_H263_PARSER 1
 #define CONFIG_H264_PARSER 1
+#define CONFIG_HEVC_PARSER 1
 #define CONFIG_MJPEG_PARSER 1
 #define CONFIG_MLP_PARSER 1
 #define CONFIG_MPEG4VIDEO_PARSER 1
@@ -746,6 +747,7 @@
 #define CONFIG_H261_DEMUXER 1
 #define CONFIG_H263_DEMUXER 1
 #define CONFIG_H264_DEMUXER 1
+#define CONFIG_HEVC_DEMUXER 1
 #define CONFIG_IDCIN_DEMUXER 1
 #define CONFIG_IFF_DEMUXER 1
 #define CONFIG_IMAGE2_DEMUXER 1
diff --git a/amffmpeg/config.mak b/amffmpeg/config.mak
index f85e1c1..f458319 100755
--- a/amffmpeg/config.mak
+++ b/amffmpeg/config.mak
@@ -744,6 +744,7 @@ CONFIG_FLAC_PARSER=yes
 CONFIG_H261_PARSER=yes
 CONFIG_H263_PARSER=yes
 CONFIG_H264_PARSER=yes
+CONFIG_HEVC_PARSER=yes
 CONFIG_MJPEG_PARSER=yes
 CONFIG_MLP_PARSER=yes
 CONFIG_MPEG4VIDEO_PARSER=yes
@@ -812,6 +813,7 @@ CONFIG_GXF_DEMUXER=yes
 CONFIG_H261_DEMUXER=yes
 CONFIG_H263_DEMUXER=yes
 CONFIG_H264_DEMUXER=yes
+CONFIG_HEVC_DEMUXER=yes
 CONFIG_IDCIN_DEMUXER=yes
 CONFIG_IFF_DEMUXER=yes
 CONFIG_IMAGE2_DEMUXER=yes
diff --git a/amffmpeg/libavcodec/Makefile b/amffmpeg/libavcodec/Makefile
index 9e67939..9480661 100755
--- a/amffmpeg/libavcodec/Makefile
+++ b/amffmpeg/libavcodec/Makefile
@@ -619,6 +619,7 @@ OBJS-$(CONFIG_H264_PARSER)             += h264_parser.o h264.o            \
                                           h264_loopfilter.o h264_cabac.o \
                                           h264_cavlc.o h264_ps.o \
                                           mpegvideo.o error_resilience.o
+OBJS-$(CONFIG_HEVC_PARSER)             += hevc_parser.o hevc.o
 OBJS-$(CONFIG_AAC_LATM_PARSER)         += latm_parser.o
 OBJS-$(CONFIG_MJPEG_PARSER)            += mjpeg_parser.o
 OBJS-$(CONFIG_MLP_PARSER)              += mlp_parser.o mlp.o
diff --git a/amffmpeg/libavcodec/allcodecs.c b/amffmpeg/libavcodec/allcodecs.c
index 23441b9..c3816db 100755
--- a/amffmpeg/libavcodec/allcodecs.c
+++ b/amffmpeg/libavcodec/allcodecs.c
@@ -405,6 +405,7 @@ void avcodec_register_all(void)
     REGISTER_PARSER  (H261, h261);
     REGISTER_PARSER  (H263, h263);
     REGISTER_PARSER  (H264, h264);
+    REGISTER_PARSER  (HEVC, hevc);
     REGISTER_PARSER  (MJPEG, mjpeg);
     REGISTER_PARSER  (MLP, mlp);
     REGISTER_PARSER  (MPEG4VIDEO, mpeg4video);
diff --git a/amffmpeg/libavcodec/avcodec.h b/amffmpeg/libavcodec/avcodec.h
index 0d4e2fd..f193ada 100755
--- a/amffmpeg/libavcodec/avcodec.h
+++ b/amffmpeg/libavcodec/avcodec.h
@@ -210,6 +210,9 @@ enum CodecID {
     /* H264 MVC type */
     CODEC_ID_H264MVC,
 
+    /* HEVC/H.265 type */
+    CODEC_ID_HEVC,
+
     /* various PCM "codecs" */
     CODEC_ID_PCM_S16LE= 0x10000,
     CODEC_ID_PCM_S16BE,
@@ -2938,6 +2941,10 @@ typedef struct AVCodecContext {
      int mpegps_video_idprobed;
 	/*for some special asf files */
 	 int durcount;
+    // need filter 10bit for hevc
+    int bit_depth;
+    // need filter long term ref pic for hevc
+    int long_term_ref_pic;
 } AVCodecContext;
 
 /**
diff --git a/amffmpeg/libavcodec/hevc.c b/amffmpeg/libavcodec/hevc.c
new file mode 100644
index 0000000..60f955c
--- /dev/null
+++ b/amffmpeg/libavcodec/hevc.c
@@ -0,0 +1,1900 @@
+/*
+ * HEVC video Decoder (just used for hevc parser by senbai.tao)
+ *
+ * Copyright (C) 2012 - 2013 Guillaume Martres
+ * Copyright (C) 2012 - 2013 Mickael Raulet
+ * Copyright (C) 2012 - 2013 Gildas Cocherel
+ * Copyright (C) 2012 - 2013 Wassim Hamidouche
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include "hevc.h"
+#include "golomb.h"
+#include "libavutil/pixdesc.h"
+#include "libavutil/imgutils.h"
+#include <pthread.h>
+
+static pthread_mutex_t atomic_lock = PTHREAD_MUTEX_INITIALIZER;
+
+//////////// copy from player_hwdec.c ///////////////////////
+int check_size_in_buffer(unsigned char *p, int len)
+{
+    unsigned int size;
+    unsigned char *q = p;
+    while ((q + 4) < (p + len)) {
+        size = (*q << 24) | (*(q + 1) << 16) | (*(q + 2) << 8) | (*(q + 3));
+        if (size & 0xff000000) {
+            return 0;
+        }
+
+        if (q + size + 4 == p + len) {
+            return 1;
+        }
+
+        q += size + 4;
+    }
+    return 0;
+}
+
+int check_size_in_buffer3(unsigned char *p, int len)
+{
+    unsigned int size;
+    unsigned char *q = p;
+    while ((q + 3) < (p + len)) {
+        size = (*q << 16) | (*(q + 1) << 8) | (*(q + 2));
+
+        if (q + size + 3 == p + len) {
+            return 1;
+        }
+
+        q += size + 3;
+    }
+    return 0;
+}
+////////////////////////////////////////////////
+
+ int ff_hevc_extract_rbsp(HEVCContext *s, const uint8_t *src, int length,
+                         HEVCNAL *nal)
+{
+    int i, si, di;
+    uint8_t *dst;
+
+    s->skipped_bytes = 0;
+#define STARTCODE_TEST                                                  \
+        if (i + 2 < length && src[i + 1] == 0 && src[i + 2] <= 3) {     \
+            if (src[i + 2] != 3) {                                      \
+                /* startcode, so we must be past the end */             \
+                length = i;                                             \
+            }                                                           \
+            break;                                                      \
+        }
+#if HAVE_FAST_UNALIGNED
+#define FIND_FIRST_ZERO                                                 \
+        if (i > 0 && !src[i])                                           \
+            i--;                                                        \
+        while (src[i])                                                  \
+            i++
+#if HAVE_FAST_64BIT
+    for (i = 0; i + 1 < length; i += 9) {
+        if (!((~AV_RN64A(src + i) &
+               (AV_RN64A(src + i) - 0x0100010001000101ULL)) &
+              0x8000800080008080ULL))
+            continue;
+        FIND_FIRST_ZERO;
+        STARTCODE_TEST;
+        i -= 7;
+    }
+#else
+    for (i = 0; i + 1 < length; i += 5) {
+        if (!((~AV_RN32A(src + i) &
+               (AV_RN32A(src + i) - 0x01000101U)) &
+              0x80008080U))
+            continue;
+        FIND_FIRST_ZERO;
+        STARTCODE_TEST;
+        i -= 3;
+    }
+#endif
+#else
+    for (i = 0; i + 1 < length; i += 2) {
+        if (src[i])
+            continue;
+        if (i > 0 && src[i - 1] == 0)
+            i--;
+        STARTCODE_TEST;
+    }
+#endif
+
+    if (i >= length - 1) { // no escaped 0
+        nal->data = src;
+        nal->size = length;
+        return length;
+    }
+
+    av_fast_malloc(&nal->rbsp_buffer, &nal->rbsp_buffer_size,
+                   length + FF_INPUT_BUFFER_PADDING_SIZE);
+    if (!nal->rbsp_buffer)
+        return AVERROR(ENOMEM);
+
+    dst = nal->rbsp_buffer;
+
+    memcpy(dst, src, i);
+    si = di = i;
+    while (si + 2 < length) {
+        // remove escapes (very rare 1:2^22)
+        if (src[si + 2] > 3) {
+            dst[di++] = src[si++];
+            dst[di++] = src[si++];
+        } else if (src[si] == 0 && src[si + 1] == 0) {
+            if (src[si + 2] == 3) { // escape
+                dst[di++] = 0;
+                dst[di++] = 0;
+                si       += 3;
+
+#if 0
+                s->skipped_bytes++;
+                if (s->skipped_bytes_pos_size < s->skipped_bytes) {
+                    s->skipped_bytes_pos_size *= 2;
+                    av_reallocp_array(&s->skipped_bytes_pos,
+                            s->skipped_bytes_pos_size,
+                            sizeof(*s->skipped_bytes_pos));
+                    if (!s->skipped_bytes_pos)
+                        return AVERROR(ENOMEM);
+                }
+                if (s->skipped_bytes_pos)
+                    s->skipped_bytes_pos[s->skipped_bytes-1] = di - 1;
+#endif
+                continue;
+            } else // next start code
+                goto nsc;
+        }
+
+        dst[di++] = src[si++];
+    }
+    while (si < length)
+        dst[di++] = src[si++];
+nsc:
+
+    memset(dst + di, 0, FF_INPUT_BUFFER_PADDING_SIZE);
+
+    nal->data = dst;
+    nal->size = di;
+    return si;
+}
+
+
+int ff_hevc_compute_poc(HEVCContext *s, int poc_lsb)
+{
+    int max_poc_lsb  = 1 << s->sps->log2_max_poc_lsb;
+    int prev_poc_lsb = s->pocTid0 % max_poc_lsb;
+    int prev_poc_msb = s->pocTid0 - prev_poc_lsb;
+    int poc_msb;
+
+    if ((poc_lsb < prev_poc_lsb) && ((prev_poc_lsb - poc_lsb) >= max_poc_lsb / 2))
+        poc_msb = prev_poc_msb + max_poc_lsb;
+    else if ((poc_lsb > prev_poc_lsb) && ((poc_lsb - prev_poc_lsb) > (max_poc_lsb / 2)))
+        poc_msb = prev_poc_msb - max_poc_lsb;
+    else
+        poc_msb = prev_poc_msb;
+
+    // For BLA picture types, POCmsb is set to 0.
+    if (s->nal_unit_type == NAL_BLA_W_LP ||
+        s->nal_unit_type == NAL_BLA_W_RADL ||
+        s->nal_unit_type == NAL_BLA_N_LP)
+        poc_msb = 0;
+
+    return poc_msb + poc_lsb;
+}
+
+const uint8_t *avpriv_find_start_code(const uint8_t * p,const uint8_t *end,uint32_t * state)
+{
+    int i;
+
+    if (p >= end)
+        return end;
+
+    for (i = 0; i < 3; i++) {
+        uint32_t tmp = *state << 8;
+        *state = tmp + *(p++);
+        if (tmp == 0x100 || p == end)
+            return p;
+    }
+
+    while (p < end) {
+        if      (p[-1] > 1      ) p += 3;
+        else if (p[-2]          ) p += 2;
+        else if (p[-3]|(p[-1]-1)) p++;
+        else {
+            p++;
+            break;
+        }
+    }
+
+    p = FFMIN(p, end) - 4;
+    *state = AV_RB32(p);
+
+    return p + 4;
+}
+
+static int avpriv_atomic_int_add_and_fetch(volatile int *ptr, int inc)
+{
+    int res;
+
+    pthread_mutex_lock(&atomic_lock);
+    *ptr += inc;
+    res = *ptr;
+    pthread_mutex_unlock(&atomic_lock);
+
+    return res;
+}
+
+void av_buffer_unref(AVBufferRef **buf)
+{
+    AVBuffer *b;
+
+    if (!buf || !*buf)
+        return;
+    b = (*buf)->buffer;
+    av_freep(buf);
+
+    if (!avpriv_atomic_int_add_and_fetch(&b->refcount, -1)) {
+        b->free(b->opaque, b->data);
+        av_freep(&b);
+    }
+}
+
+/**
+ * Always treat the buffer as read-only, even when it has only one
+ * reference.
+ */
+#define AV_BUFFER_FLAG_READONLY (1 << 0)
+
+/**
+ * The buffer is always treated as read-only.
+ */
+#define BUFFER_FLAG_READONLY      (1 << 0)
+
+static void av_buffer_default_free(void *opaque, uint8_t *data)
+{
+    av_free(data);
+}
+
+static AVBufferRef *av_buffer_create(uint8_t *data, int size,
+                              void (*free)(void *opaque, uint8_t *data),
+                              void *opaque, int flags)
+{
+    AVBufferRef *ref = NULL;
+    AVBuffer    *buf = NULL;
+
+    buf = av_mallocz(sizeof(*buf));
+    if (!buf)
+        return NULL;
+
+    buf->data     = data;
+    buf->size     = size;
+    buf->free     = free ? free : av_buffer_default_free;
+    buf->opaque   = opaque;
+    buf->refcount = 1;
+
+    if (flags & AV_BUFFER_FLAG_READONLY)
+        buf->flags |= BUFFER_FLAG_READONLY;
+
+    ref = av_mallocz(sizeof(*ref));
+    if (!ref) {
+        av_freep(&buf);
+        return NULL;
+    }
+
+    ref->buffer = buf;
+    ref->data   = data;
+    ref->size   = size;
+
+    return ref;
+}
+
+static AVBufferRef *av_buffer_alloc(int size)
+{
+    AVBufferRef *ret = NULL;
+    uint8_t    *data = NULL;
+
+    data = av_malloc(size);
+    if (!data)
+        return NULL;
+
+    ret = av_buffer_create(data, size, av_buffer_default_free, NULL, 0);
+    if (!ret)
+        av_freep(&data);
+
+    return ret;
+}
+
+
+static AVBufferRef *av_buffer_allocz(int size)
+{
+    AVBufferRef *ret = av_buffer_alloc(size);
+    if (!ret)
+        return NULL;
+
+    memset(ret->data, 0, size);
+    return ret;
+}
+
+//////////// hevc_ps.c //////////////////
+static const uint8_t ff_hevc_diag_scan4x4_x[16] = {
+    0, 0, 1, 0,
+    1, 2, 0, 1,
+    2, 3, 1, 2,
+    3, 2, 3, 3,
+};
+
+static const uint8_t ff_hevc_diag_scan4x4_y[16] = {
+    0, 1, 0, 2,
+    1, 0, 3, 2,
+    1, 0, 3, 2,
+    1, 3, 2, 3,
+};
+
+static const uint8_t diag_scan4x4_inv[4][4] = {
+    { 0,  2,  5,  9, },
+    { 1,  4,  8, 12, },
+    { 3,  7, 11, 14, },
+    { 6, 10, 13, 15, },
+};
+
+static const uint8_t ff_hevc_diag_scan8x8_x[64] = {
+    0, 0, 1, 0,
+    1, 2, 0, 1,
+    2, 3, 0, 1,
+    2, 3, 4, 0,
+    1, 2, 3, 4,
+    5, 0, 1, 2,
+    3, 4, 5, 6,
+    0, 1, 2, 3,
+    4, 5, 6, 7,
+    1, 2, 3, 4,
+    5, 6, 7, 2,
+    3, 4, 5, 6,
+    7, 3, 4, 5,
+    6, 7, 4, 5,
+    6, 7, 5, 6,
+    7, 6, 7, 7,
+};
+
+static const uint8_t ff_hevc_diag_scan8x8_y[64] = {
+    0, 1, 0, 2,
+    1, 0, 3, 2,
+    1, 0, 4, 3,
+    2, 1, 0, 5,
+    4, 3, 2, 1,
+    0, 6, 5, 4,
+    3, 2, 1, 0,
+    7, 6, 5, 4,
+    3, 2, 1, 0,
+    7, 6, 5, 4,
+    3, 2, 1, 7,
+    6, 5, 4, 3,
+    2, 7, 6, 5,
+    4, 3, 7, 6,
+    5, 4, 7, 6,
+    5, 7, 6, 7,
+};
+
+static const uint8_t default_scaling_list_intra[] = {
+    16, 16, 16, 16, 17, 18, 21, 24,
+    16, 16, 16, 16, 17, 19, 22, 25,
+    16, 16, 17, 18, 20, 22, 25, 29,
+    16, 16, 18, 21, 24, 27, 31, 36,
+    17, 17, 20, 24, 30, 35, 41, 47,
+    18, 19, 22, 27, 35, 44, 54, 65,
+    21, 22, 25, 31, 41, 54, 70, 88,
+    24, 25, 29,36, 47, 65, 88, 115
+};
+
+static const uint8_t default_scaling_list_inter[] = {
+    16, 16, 16, 16, 17, 18, 20, 24,
+    16, 16, 16, 17, 18, 20, 24, 25,
+    16, 16, 17, 18, 20, 24, 25, 28,
+    16, 17, 18, 20, 24, 25, 28, 33,
+    17, 18, 20, 24, 25, 28, 33, 41,
+    18, 20, 24, 25, 28, 33, 41, 54,
+    20, 24, 25, 28, 33, 41, 54, 71,
+    24, 25, 28, 33, 41, 54, 71, 91
+};
+
+static const AVRational vui_sar[] = {
+    { 0,   1  },
+    { 1,   1  },
+    { 12,  11 },
+    { 10,  11 },
+    { 16,  11 },
+    { 40,  33 },
+    { 24,  11 },
+    { 20,  11 },
+    { 32,  11 },
+    { 80,  33 },
+    { 18,  11 },
+    { 15,  11 },
+    { 64,  33 },
+    { 160, 99 },
+    { 4,   3  },
+    { 3,   2  },
+    { 2,   1  },
+};
+
+static void set_default_scaling_list_data(ScalingList *sl)
+{
+    int matrixId;
+
+    for (matrixId = 0; matrixId < 6; matrixId++) {
+        // 4x4 default is 16
+        memset(sl->sl[0][matrixId], 16, 16);
+        sl->sl_dc[0][matrixId] = 16; // default for 16x16
+        sl->sl_dc[1][matrixId] = 16; // default for 32x32
+    }
+    memcpy(sl->sl[1][0], default_scaling_list_intra, 64);
+    memcpy(sl->sl[1][1], default_scaling_list_intra, 64);
+    memcpy(sl->sl[1][2], default_scaling_list_intra, 64);
+    memcpy(sl->sl[1][3], default_scaling_list_inter, 64);
+    memcpy(sl->sl[1][4], default_scaling_list_inter, 64);
+    memcpy(sl->sl[1][5], default_scaling_list_inter, 64);
+    memcpy(sl->sl[2][0], default_scaling_list_intra, 64);
+    memcpy(sl->sl[2][1], default_scaling_list_intra, 64);
+    memcpy(sl->sl[2][2], default_scaling_list_intra, 64);
+    memcpy(sl->sl[2][3], default_scaling_list_inter, 64);
+    memcpy(sl->sl[2][4], default_scaling_list_inter, 64);
+    memcpy(sl->sl[2][5], default_scaling_list_inter, 64);
+    memcpy(sl->sl[3][0], default_scaling_list_intra, 64);
+    memcpy(sl->sl[3][1], default_scaling_list_inter, 64);
+}
+
+static int scaling_list_data(HEVCContext *s, ScalingList *sl)
+{
+    GetBitContext *gb = &s->HEVClc->gb;
+    uint8_t scaling_list_pred_mode_flag[4][6];
+    int32_t scaling_list_dc_coef[2][6];
+
+    int size_id, matrix_id, i, pos, delta;
+    for (size_id = 0; size_id < 4; size_id++)
+        for (matrix_id = 0; matrix_id < ((size_id == 3) ? 2 : 6); matrix_id++) {
+            scaling_list_pred_mode_flag[size_id][matrix_id] = get_bits1(gb);
+            if (!scaling_list_pred_mode_flag[size_id][matrix_id]) {
+                delta = get_ue_golomb_long(gb);
+                // Only need to handle non-zero delta. Zero means default, which should already be in the arrays.
+                if (delta) {
+                    // Copy from previous array.
+                    if (matrix_id - delta < 0) {
+                        av_log(s->avctx, AV_LOG_ERROR,
+                               "Invalid delta in scaling list data: %d.\n", delta);
+                        return AVERROR_INVALIDDATA;
+                    }
+
+                    memcpy(sl->sl[size_id][matrix_id],
+                           sl->sl[size_id][matrix_id - delta],
+                           size_id > 0 ? 64 : 16);
+                    if (size_id > 1)
+                        sl->sl_dc[size_id - 2][matrix_id] = sl->sl_dc[size_id - 2][matrix_id - delta];
+                }
+            } else {
+                int next_coef;
+                int coef_num;
+                int32_t scaling_list_delta_coef;
+
+                next_coef = 8;
+                coef_num = FFMIN(64, (1  <<  (4 + (size_id  <<  1))));
+                if (size_id > 1) {
+                    scaling_list_dc_coef[size_id - 2][matrix_id] = get_se_golomb(gb) + 8;
+                    next_coef = scaling_list_dc_coef[size_id - 2][matrix_id];
+                    sl->sl_dc[size_id - 2][matrix_id] = next_coef;
+                }
+                for (i = 0; i < coef_num; i++) {
+                    if (size_id == 0)
+                        pos = 4 * ff_hevc_diag_scan4x4_y[i] + ff_hevc_diag_scan4x4_x[i];
+                    else
+                        pos = 8 * ff_hevc_diag_scan8x8_y[i] + ff_hevc_diag_scan8x8_x[i];
+
+                    scaling_list_delta_coef = get_se_golomb(gb);
+                    next_coef = (next_coef + scaling_list_delta_coef + 256 ) % 256;
+                    sl->sl[size_id][matrix_id][pos] = next_coef;
+                }
+            }
+        }
+
+    return 0;
+}
+
+static int ff_hevc_decode_short_term_rps(HEVCContext *s, ShortTermRPS *rps,
+                                  const HEVCSPS *sps, int is_slice_header)
+{
+    HEVCLocalContext *lc = s->HEVClc;
+    uint8_t rps_predict = 0;
+    int delta_poc;
+    int k0 = 0;
+    int k1 = 0;
+    int k  = 0;
+    int i;
+
+    GetBitContext *gb = &lc->gb;
+
+    if (rps != sps->st_rps && sps->nb_st_rps)
+        rps_predict  = get_bits1(gb);
+
+    if (rps_predict) {
+        const ShortTermRPS *rps_ridx;
+        int delta_rps, abs_delta_rps;
+        uint8_t use_delta_flag = 0;
+        uint8_t delta_rps_sign;
+
+        if (is_slice_header) {
+            int delta_idx = get_ue_golomb_long(gb) + 1;
+            if (delta_idx > sps->nb_st_rps) {
+                av_log(s->avctx, AV_LOG_ERROR, "Invalid value of delta_idx "
+                       "in slice header RPS: %d > %d.\n", delta_idx,
+                       sps->nb_st_rps);
+                return AVERROR_INVALIDDATA;
+            }
+            rps_ridx = &sps->st_rps[sps->nb_st_rps - delta_idx];
+        } else
+            rps_ridx = &sps->st_rps[rps - sps->st_rps - 1];
+
+        delta_rps_sign = get_bits1(gb);
+        abs_delta_rps  = get_ue_golomb_long(gb) + 1;
+        delta_rps      = (1 - (delta_rps_sign << 1)) * abs_delta_rps;
+        for (i = 0; i <= rps_ridx->num_delta_pocs; i++) {
+            int used = rps->used[k] = get_bits1(gb);
+
+            if (!used)
+                use_delta_flag = get_bits1(gb);
+
+            if (used || use_delta_flag) {
+                if (i < rps_ridx->num_delta_pocs)
+                    delta_poc = delta_rps + rps_ridx->delta_poc[i];
+                else
+                    delta_poc = delta_rps;
+                rps->delta_poc[k] = delta_poc;
+                if (delta_poc < 0)
+                    k0++;
+                else
+                    k1++;
+                k++;
+            }
+        }
+
+        rps->num_delta_pocs    = k;
+        rps->num_negative_pics = k0;
+        // sort in increasing order (smallest first)
+        if (rps->num_delta_pocs != 0) {
+            int used, tmp;
+            for (i = 1; i < rps->num_delta_pocs; i++) {
+                delta_poc = rps->delta_poc[i];
+                used      = rps->used[i];
+                for (k = i-1 ; k >= 0;  k--) {
+                    tmp = rps->delta_poc[k];
+                    if (delta_poc < tmp ) {
+                        rps->delta_poc[k+1] = tmp;
+                        rps->used[k+1]      = rps->used[k];
+                        rps->delta_poc[k]   = delta_poc;
+                        rps->used[k]        = used;
+                    }
+                }
+            }
+        }
+        if ((rps->num_negative_pics >> 1) != 0) {
+            int used;
+            k = rps->num_negative_pics - 1;
+            // flip the negative values to largest first
+            for (i = 0; i < rps->num_negative_pics>>1; i++) {
+                delta_poc          = rps->delta_poc[i];
+                used               = rps->used[i];
+                rps->delta_poc[i]  = rps->delta_poc[k];
+                rps->used[i]       = rps->used[k];
+                rps->delta_poc[k]  = delta_poc;
+                rps->used[k]       = used;
+                k--;
+            }
+        }
+    } else {
+        unsigned int prev, nb_positive_pics;
+        rps->num_negative_pics = get_ue_golomb_long(gb);
+        nb_positive_pics       = get_ue_golomb_long(gb);
+
+        if (rps->num_negative_pics >= MAX_REFS ||
+            nb_positive_pics >= MAX_REFS) {
+            av_log(s->avctx, AV_LOG_ERROR, "Too many refs in a short term RPS.\n");
+            return AVERROR_INVALIDDATA;
+        }
+
+        rps->num_delta_pocs = rps->num_negative_pics + nb_positive_pics;
+        if (rps->num_delta_pocs) {
+            prev = 0;
+            for (i = 0; i < rps->num_negative_pics; i++) {
+                delta_poc = get_ue_golomb_long(gb) + 1;
+                prev -= delta_poc;
+                rps->delta_poc[i] = prev;
+                rps->used[i] = get_bits1(gb);
+            }
+            prev = 0;
+            for (i = 0; i < nb_positive_pics; i++) {
+                delta_poc = get_ue_golomb_long(gb) + 1;
+                prev += delta_poc;
+                rps->delta_poc[rps->num_negative_pics + i] = prev;
+                rps->used[rps->num_negative_pics + i] = get_bits1(gb);
+            }
+        }
+    }
+    return 0;
+}
+
+static int decode_profile_tier_level(HEVCContext *s, PTL *ptl, int max_num_sub_layers)
+{
+    HEVCLocalContext *lc = s->HEVClc;
+    GetBitContext *gb = &lc->gb;
+    int i, j;
+
+    ptl->general_profile_space = get_bits(gb, 2);
+    ptl->general_tier_flag = get_bits1(gb);
+    ptl->general_profile_idc = get_bits(gb, 5);
+    if (ptl->general_profile_idc == 1)
+        av_log(s->avctx, AV_LOG_DEBUG, "Main profile bitstream\n");
+    else if (ptl->general_profile_idc == 2)
+        av_log(s->avctx, AV_LOG_DEBUG, "Main10 profile bitstream\n");
+    else
+        av_log(s->avctx, AV_LOG_WARNING, "No profile indication! (%d)\n", ptl->general_profile_idc);
+
+    for (i = 0; i < 32; i++)
+        ptl->general_profile_compatibility_flag[i] = get_bits1(gb);
+    skip_bits1(gb);// general_progressive_source_flag
+    skip_bits1(gb);// general_interlaced_source_flag
+    skip_bits1(gb);// general_non_packed_constraint_flag
+    skip_bits1(gb);// general_frame_only_constraint_flag
+    if (get_bits(gb, 16) != 0) // XXX_reserved_zero_44bits[0..15]
+        return -1;
+    if (get_bits(gb, 16) != 0) // XXX_reserved_zero_44bits[16..31]
+        return -1;
+    if (get_bits(gb, 12) != 0) // XXX_reserved_zero_44bits[32..43]
+        return -1;
+
+    ptl->general_level_idc = get_bits(gb, 8);
+    for (i = 0; i < max_num_sub_layers - 1; i++) {
+        ptl->sub_layer_profile_present_flag[i] = get_bits1(gb);
+        ptl->sub_layer_level_present_flag[i] = get_bits1(gb);
+    }
+    if (max_num_sub_layers - 1 > 0)
+        for (i = max_num_sub_layers - 1; i < 8; i++)
+            skip_bits(gb, 2); // reserved_zero_2bits[i]
+    for (i = 0; i < max_num_sub_layers - 1; i++) {
+        if (ptl->sub_layer_profile_present_flag[i]) {
+            ptl->sub_layer_profile_space[i] = get_bits(gb, 2);
+            ptl->sub_layer_tier_flag[i] = get_bits(gb, 1);
+            ptl->sub_layer_profile_idc[i] = get_bits(gb, 5);
+            for (j = 0; j < 32; j++)
+                ptl->sub_layer_profile_compatibility_flags[i][j] = get_bits1(gb);
+            skip_bits1(gb);// sub_layer_progressive_source_flag
+            skip_bits1(gb);// sub_layer_interlaced_source_flag
+            skip_bits1(gb);// sub_layer_non_packed_constraint_flag
+            skip_bits1(gb);// sub_layer_frame_only_constraint_flag
+
+            if (get_bits(gb, 16) != 0) // sub_layer_reserved_zero_44bits[0..15]
+                return -1;
+            if (get_bits(gb, 16) != 0) // sub_layer_reserved_zero_44bits[16..31]
+                return -1;
+            if (get_bits(gb, 12) != 0) // sub_layer_reserved_zero_44bits[32..43]
+                return -1;
+        }
+        if (ptl->sub_layer_level_present_flag[i])
+            ptl->sub_layer_level_idc[i] = get_bits(gb, 8);
+    }
+    return 0;
+}
+
+static void decode_sublayer_hrd(HEVCContext *s, int nb_cpb, int subpic_params_present)
+{
+    GetBitContext *gb = &s->HEVClc->gb;
+    int i;
+
+    for (i = 0; i < nb_cpb; i++) {
+        get_ue_golomb_long(gb); // bit_rate_value_minus1
+        get_ue_golomb_long(gb); // cpb_size_value_minus1
+
+        if (subpic_params_present) {
+            get_ue_golomb_long(gb); // cpb_size_du_value_minus1
+            get_ue_golomb_long(gb); // bit_rate_du_value_minus1
+        }
+        skip_bits1(gb); // cbr_flag
+    }
+}
+
+static void decode_hrd(HEVCContext *s, int common_inf_present, int max_sublayers)
+{
+    GetBitContext *gb = &s->HEVClc->gb;
+    int nal_params_present = 0, vcl_params_present = 0;
+    int subpic_params_present = 0;
+    int i;
+
+    if (common_inf_present) {
+        nal_params_present = get_bits1(gb);
+        vcl_params_present = get_bits1(gb);
+
+        if (nal_params_present || vcl_params_present) {
+            subpic_params_present = get_bits1(gb);
+
+            if (subpic_params_present) {
+                skip_bits(gb, 8); // tick_divisor_minus2
+                skip_bits(gb, 5); // du_cpb_removal_delay_increment_length_minus1
+                skip_bits(gb, 1); // sub_pic_cpb_params_in_pic_timing_sei_flag
+                skip_bits(gb, 5); // dpb_output_delay_du_length_minus1
+            }
+
+            skip_bits(gb, 4); // bit_rate_scale
+            skip_bits(gb, 4); // cpb_size_scale
+
+            if (subpic_params_present)
+                skip_bits(gb, 4); // cpb_size_du_scale
+
+            skip_bits(gb, 5); // initial_cpb_removal_delay_length_minus1
+            skip_bits(gb, 5); // au_cpb_removal_delay_length_minus1
+            skip_bits(gb, 5); // dpb_output_delay_length_minus1
+        }
+    }
+
+    for (i = 0; i < max_sublayers; i++) {
+        int low_delay = 0;
+        int nb_cpb = 1;
+        int fixed_rate = get_bits1(gb);
+
+        if (!fixed_rate)
+            fixed_rate = get_bits1(gb);
+
+        if (fixed_rate)
+            get_ue_golomb_long(gb); // elemental_duration_in_tc_minus1
+        else
+            low_delay = get_bits1(gb);
+
+        if (!low_delay)
+            nb_cpb = get_ue_golomb_long(gb) + 1;
+
+        if (nal_params_present)
+            decode_sublayer_hrd(s, nb_cpb, subpic_params_present);
+        if (vcl_params_present)
+            decode_sublayer_hrd(s, nb_cpb, subpic_params_present);
+    }
+}
+
+static void decode_vui(HEVCContext *s, HEVCSPS *sps)
+{
+    VUI *vui = &sps->vui;
+    GetBitContext *gb = &s->HEVClc->gb;
+    int sar_present;
+
+    av_log(s->avctx, AV_LOG_DEBUG, "Decoding VUI\n");
+
+    sar_present = get_bits1(gb);
+    if (sar_present) {
+        uint8_t sar_idx = get_bits(gb, 8);
+        if (sar_idx < FF_ARRAY_ELEMS(vui_sar))
+            vui->sar = vui_sar[sar_idx];
+        else if (sar_idx == 255) {
+            vui->sar.num = get_bits(gb, 16);
+            vui->sar.den = get_bits(gb, 16);
+        } else
+            av_log(s->avctx, AV_LOG_WARNING, "Unknown SAR index: %u.\n",
+                   sar_idx);
+    }
+
+    vui->overscan_info_present_flag = get_bits1(gb);
+    if (vui->overscan_info_present_flag)
+        vui->overscan_appropriate_flag = get_bits1(gb);
+
+    vui->video_signal_type_present_flag = get_bits1(gb);
+    if (vui->video_signal_type_present_flag) {
+        vui->video_format                    = get_bits(gb, 3);
+        vui->video_full_range_flag           = get_bits1(gb);
+        vui->colour_description_present_flag = get_bits1(gb);
+        if (vui->colour_description_present_flag) {
+            vui->colour_primaries        = get_bits(gb, 8);
+            vui->transfer_characteristic = get_bits(gb, 8);
+            vui->matrix_coeffs           = get_bits(gb, 8);
+        }
+    }
+
+    vui->chroma_loc_info_present_flag = get_bits1(gb);
+    if (vui->chroma_loc_info_present_flag) {
+        vui->chroma_sample_loc_type_top_field    = get_ue_golomb_long(gb);
+        vui->chroma_sample_loc_type_bottom_field = get_ue_golomb_long(gb);
+    }
+
+    vui->neutra_chroma_indication_flag = get_bits1(gb);
+    vui->field_seq_flag                = get_bits1(gb);
+    vui->frame_field_info_present_flag = get_bits1(gb);
+
+    vui->default_display_window_flag = get_bits1(gb);
+    if (vui->default_display_window_flag) {
+        //TODO: * 2 is only valid for 420
+        vui->def_disp_win.left_offset   = get_ue_golomb_long(gb) * 2;
+        vui->def_disp_win.right_offset  = get_ue_golomb_long(gb) * 2;
+        vui->def_disp_win.top_offset    = get_ue_golomb_long(gb) * 2;
+        vui->def_disp_win.bottom_offset = get_ue_golomb_long(gb) * 2;
+/*
+        if (s->strict_def_disp_win &&
+            s->avctx->flags2 & CODEC_FLAG2_IGNORE_CROP) {
+            av_log(s->avctx, AV_LOG_DEBUG,
+                   "discarding vui default display window, "
+                   "original values are l:%u r:%u t:%u b:%u\n",
+                   vui->def_disp_win.left_offset,
+                   vui->def_disp_win.right_offset,
+                   vui->def_disp_win.top_offset,
+                   vui->def_disp_win.bottom_offset);
+
+            vui->def_disp_win.left_offset   =
+            vui->def_disp_win.right_offset  =
+            vui->def_disp_win.top_offset    =
+            vui->def_disp_win.bottom_offset = 0;
+        }
+*/
+    }
+
+    vui->vui_timing_info_present_flag = get_bits1(gb);
+    if (vui->vui_timing_info_present_flag) {
+        vui->vui_num_units_in_tick               = get_bits(gb, 32);
+        vui->vui_time_scale                      = get_bits(gb, 32);
+        vui->vui_poc_proportional_to_timing_flag = get_bits1(gb);
+        if (vui->vui_poc_proportional_to_timing_flag)
+            vui->vui_num_ticks_poc_diff_one_minus1 = get_ue_golomb_long(gb);
+        vui->vui_hrd_parameters_present_flag = get_bits1(gb);
+        if (vui->vui_hrd_parameters_present_flag)
+            decode_hrd(s, 1, sps->max_sub_layers);
+    }
+
+    vui->bitstream_restriction_flag = get_bits1(gb);
+    if (vui->bitstream_restriction_flag) {
+        vui->tiles_fixed_structure_flag              = get_bits1(gb);
+        vui->motion_vectors_over_pic_boundaries_flag = get_bits1(gb);
+        vui->restricted_ref_pic_lists_flag           = get_bits1(gb);
+        vui->min_spatial_segmentation_idc            = get_ue_golomb_long(gb);
+        vui->max_bytes_per_pic_denom                 = get_ue_golomb_long(gb);
+        vui->max_bits_per_min_cu_denom               = get_ue_golomb_long(gb);
+        vui->log2_max_mv_length_horizontal           = get_ue_golomb_long(gb);
+        vui->log2_max_mv_length_vertical             = get_ue_golomb_long(gb);
+    }
+}
+
+int ff_hevc_decode_nal_vps(HEVCContext *s)
+{
+    int i,j;
+    GetBitContext *gb = &s->HEVClc->gb;
+    int vps_id = 0;
+    VPS *vps;
+
+    av_log(s->avctx, AV_LOG_DEBUG, "Decoding VPS\n");
+
+    vps = av_mallocz(sizeof(*vps));
+    if (!vps)
+        return AVERROR(ENOMEM);
+
+    vps_id = get_bits(gb, 4);
+    if (vps_id >= MAX_VPS_COUNT) {
+        av_log(s->avctx, AV_LOG_ERROR, "VPS id out of range: %d\n", vps_id);
+        goto err;
+    }
+
+    if (get_bits(gb, 2) != 3) { // vps_reserved_three_2bits
+        av_log(s->avctx, AV_LOG_ERROR, "vps_reserved_three_2bits is not three\n");
+        goto err;
+    }
+
+    vps->vps_max_layers               = get_bits(gb, 6) + 1;
+    vps->vps_max_sub_layers           = get_bits(gb, 3) + 1;
+    vps->vps_temporal_id_nesting_flag = get_bits1(gb);
+
+    if (get_bits(gb, 16) != 0xffff) { // vps_reserved_ffff_16bits
+        av_log(s->avctx, AV_LOG_ERROR, "vps_reserved_ffff_16bits is not 0xffff\n");
+        goto err;
+    }
+
+    if (vps->vps_max_sub_layers > MAX_SUB_LAYERS) {
+        av_log(s->avctx, AV_LOG_ERROR, "vps_max_sub_layers out of range: %d\n",
+               vps->vps_max_sub_layers);
+        goto err;
+    }
+
+    if (decode_profile_tier_level(s, &vps->ptl, vps->vps_max_sub_layers) < 0) {
+        av_log(s->avctx, AV_LOG_ERROR, "Error decoding profile tier level.\n");
+        goto err;
+    }
+    vps->vps_sub_layer_ordering_info_present_flag = get_bits1(gb);
+
+    i = vps->vps_sub_layer_ordering_info_present_flag ? 0 : vps->vps_max_sub_layers - 1;
+    for (; i < vps->vps_max_sub_layers; i++) {
+        vps->vps_max_dec_pic_buffering[i] = get_ue_golomb_long(gb) + 1;
+        vps->vps_num_reorder_pics[i]      = get_ue_golomb_long(gb);
+        vps->vps_max_latency_increase[i]  = get_ue_golomb_long(gb) - 1;
+
+        if (vps->vps_max_dec_pic_buffering[i] > MAX_DPB_SIZE) {
+            av_log(s->avctx, AV_LOG_ERROR, "vps_max_dec_pic_buffering_minus1 out of range: %d\n",
+                   vps->vps_max_dec_pic_buffering[i] - 1);
+            goto err;
+        }
+        if (vps->vps_num_reorder_pics[i] > vps->vps_max_dec_pic_buffering[i] - 1) {
+            av_log(s->avctx, AV_LOG_ERROR, "vps_max_num_reorder_pics out of range: %d\n",
+                   vps->vps_num_reorder_pics[i]);
+            goto err;
+        }
+    }
+
+    vps->vps_max_layer_id   = get_bits(gb, 6);
+    vps->vps_num_layer_sets = get_ue_golomb_long(gb) + 1;
+    for (i = 1; i < vps->vps_num_layer_sets; i++)
+        for (j = 0; j <= vps->vps_max_layer_id; j++)
+            skip_bits(gb, 1); // layer_id_included_flag[i][j]
+
+    vps->vps_timing_info_present_flag = get_bits1(gb);
+    if (vps->vps_timing_info_present_flag) {
+        vps->vps_num_units_in_tick               = get_bits_long(gb, 32);
+        vps->vps_time_scale                      = get_bits_long(gb, 32);
+        vps->vps_poc_proportional_to_timing_flag = get_bits1(gb);
+        if (vps->vps_poc_proportional_to_timing_flag)
+            vps->vps_num_ticks_poc_diff_one = get_ue_golomb_long(gb) + 1;
+        vps->vps_num_hrd_parameters = get_ue_golomb_long(gb);
+        for (i = 0; i < vps->vps_num_hrd_parameters; i++) {
+            int common_inf_present = 1;
+
+            get_ue_golomb_long(gb); // hrd_layer_set_idx
+            if (i)
+                common_inf_present = get_bits1(gb);
+            decode_hrd(s, common_inf_present, vps->vps_max_sub_layers);
+        }
+    }
+    get_bits1(gb); /* vps_extension_flag */
+
+    av_free(s->vps_list[vps_id]);
+    s->vps_list[vps_id] = vps;
+    return 0;
+
+err:
+    av_free(vps);
+    return AVERROR_INVALIDDATA;
+}
+
+int ff_hevc_decode_nal_sps(HEVCContext *s)
+{
+    const AVPixFmtDescriptor *desc;
+    GetBitContext *gb = &s->HEVClc->gb;
+    int ret    = 0;
+    int sps_id = 0;
+    int log2_diff_max_min_transform_block_size;
+    int bit_depth_chroma, start, vui_present, sublayer_ordering_info;
+    int i;
+
+    HEVCSPS *sps;
+    AVBufferRef *sps_buf = av_buffer_allocz(sizeof(*sps));
+
+    if (!sps_buf)
+        return AVERROR(ENOMEM);
+    sps = (HEVCSPS*)sps_buf->data;
+
+    av_log(s->avctx, AV_LOG_DEBUG, "Decoding SPS\n");
+
+    // Coded parameters
+
+    sps->vps_id = get_bits(gb, 4);
+    if (sps->vps_id >= MAX_VPS_COUNT) {
+        av_log(s->avctx, AV_LOG_ERROR, "VPS id out of range: %d\n", sps->vps_id);
+        ret = AVERROR_INVALIDDATA;
+        goto err;
+    }
+
+    sps->max_sub_layers = get_bits(gb, 3) + 1;
+    if (sps->max_sub_layers > MAX_SUB_LAYERS) {
+        av_log(s->avctx, AV_LOG_ERROR, "sps_max_sub_layers out of range: %d\n",
+               sps->max_sub_layers);
+        ret = AVERROR_INVALIDDATA;
+        goto err;
+    }
+
+    skip_bits1(gb); // temporal_id_nesting_flag
+    if (decode_profile_tier_level(s, &sps->ptl, sps->max_sub_layers) < 0) {
+        av_log(s->avctx, AV_LOG_ERROR, "error decoding profile tier level\n");
+        ret = AVERROR_INVALIDDATA;
+        goto err;
+    }
+    sps_id = get_ue_golomb_long(gb);
+    if (sps_id >= MAX_SPS_COUNT) {
+        av_log(s->avctx, AV_LOG_ERROR, "SPS id out of range: %d\n", sps_id);
+        ret = AVERROR_INVALIDDATA;
+        goto err;
+    }
+
+    sps->chroma_format_idc = get_ue_golomb_long(gb);
+    if (sps->chroma_format_idc != 1) {
+        //avpriv_report_missing_feature(s->avctx, "chroma_format_idc != 1\n");
+        ret = AVERROR_INVALIDDATA;
+        goto err;
+    }
+
+    if (sps->chroma_format_idc == 3)
+        sps->separate_colour_plane_flag = get_bits1(gb);
+
+    sps->width  = get_ue_golomb_long(gb);
+    sps->height = get_ue_golomb_long(gb);
+    if ((ret = av_image_check_size(sps->width,
+                                   sps->height, 0, s->avctx)) < 0)
+        goto err;
+
+    if (get_bits1(gb)) { // pic_conformance_flag
+        //TODO: * 2 is only valid for 420
+        sps->pic_conf_win.left_offset   = get_ue_golomb_long(gb) * 2;
+        sps->pic_conf_win.right_offset  = get_ue_golomb_long(gb) * 2;
+        sps->pic_conf_win.top_offset    = get_ue_golomb_long(gb) * 2;
+        sps->pic_conf_win.bottom_offset = get_ue_golomb_long(gb) * 2;
+
+/*
+        if (s->avctx->flags2 & CODEC_FLAG2_IGNORE_CROP) {
+            av_log(s->avctx, AV_LOG_DEBUG,
+                   "discarding sps conformance window, "
+                   "original values are l:%u r:%u t:%u b:%u\n",
+                   sps->pic_conf_win.left_offset,
+                   sps->pic_conf_win.right_offset,
+                   sps->pic_conf_win.top_offset,
+                   sps->pic_conf_win.bottom_offset);
+
+            sps->pic_conf_win.left_offset   =
+            sps->pic_conf_win.right_offset  =
+            sps->pic_conf_win.top_offset    =
+            sps->pic_conf_win.bottom_offset = 0;
+        }
+*/
+        sps->output_window = sps->pic_conf_win;
+    }
+
+    sps->bit_depth   = get_ue_golomb_long(gb) + 8;
+    bit_depth_chroma = get_ue_golomb_long(gb) + 8;
+    if (bit_depth_chroma != sps->bit_depth) {
+        av_log(s->avctx, AV_LOG_ERROR,
+               "Luma bit depth (%d) is different from chroma bit depth (%d), this is unsupported.\n",
+               sps->bit_depth, bit_depth_chroma);
+        ret = AVERROR_INVALIDDATA;
+        goto err;
+    }
+
+    if (sps->chroma_format_idc == 1) {
+        switch (sps->bit_depth) {
+        case 8:  sps->pix_fmt = PIX_FMT_YUV420P;   break;
+        case 9:  sps->pix_fmt = PIX_FMT_YUV420P9;  break;
+        case 10: sps->pix_fmt = PIX_FMT_YUV420P10; break;
+        default:
+            av_log(s->avctx, AV_LOG_ERROR, "Unsupported bit depth: %d\n",
+                   sps->bit_depth);
+            ret = AVERROR_PATCHWELCOME;
+            goto err;
+        }
+    } else {
+        av_log(s->avctx, AV_LOG_ERROR, "non-4:2:0 support is currently unspecified.\n");
+        return AVERROR_PATCHWELCOME;
+    }
+
+    desc = av_pix_fmt_desc_get(sps->pix_fmt);
+    if (!desc) {
+        ret = AVERROR(EINVAL);
+        goto err;
+    }
+
+    sps->hshift[0] = sps->vshift[0] = 0;
+    sps->hshift[2] = sps->hshift[1] = desc->log2_chroma_w;
+    sps->vshift[2] = sps->vshift[1] = desc->log2_chroma_h;
+
+    sps->pixel_shift = sps->bit_depth > 8;
+
+    sps->log2_max_poc_lsb = get_ue_golomb_long(gb) + 4;
+    if (sps->log2_max_poc_lsb > 16) {
+        av_log(s->avctx, AV_LOG_ERROR, "log2_max_pic_order_cnt_lsb_minus4 out range: %d\n",
+               sps->log2_max_poc_lsb - 4);
+        ret = AVERROR_INVALIDDATA;
+        goto err;
+    }
+
+    sublayer_ordering_info = get_bits1(gb);
+    start = sublayer_ordering_info ? 0 : sps->max_sub_layers - 1;
+    for (i = start; i < sps->max_sub_layers; i++) {
+        sps->temporal_layer[i].max_dec_pic_buffering = get_ue_golomb_long(gb) + 1;
+        sps->temporal_layer[i].num_reorder_pics      = get_ue_golomb_long(gb);
+        sps->temporal_layer[i].max_latency_increase  = get_ue_golomb_long(gb) - 1;
+        if (sps->temporal_layer[i].max_dec_pic_buffering > MAX_DPB_SIZE) {
+            av_log(s->avctx, AV_LOG_ERROR, "sps_max_dec_pic_buffering_minus1 out of range: %d\n",
+                   sps->temporal_layer[i].max_dec_pic_buffering - 1);
+            ret = AVERROR_INVALIDDATA;
+            goto err;
+        }
+        if (sps->temporal_layer[i].num_reorder_pics > sps->temporal_layer[i].max_dec_pic_buffering - 1) {
+            av_log(s->avctx, AV_LOG_ERROR, "sps_max_num_reorder_pics out of range: %d\n",
+                   sps->temporal_layer[i].num_reorder_pics);
+            ret = AVERROR_INVALIDDATA;
+            goto err;
+        }
+    }
+
+    if (!sublayer_ordering_info) {
+        for (i = 0; i < start; i++){
+            sps->temporal_layer[i].max_dec_pic_buffering = sps->temporal_layer[start].max_dec_pic_buffering;
+            sps->temporal_layer[i].num_reorder_pics      = sps->temporal_layer[start].num_reorder_pics;
+            sps->temporal_layer[i].max_latency_increase  = sps->temporal_layer[start].max_latency_increase;
+        }
+    }
+
+    sps->log2_min_cb_size             = get_ue_golomb_long(gb) + 3;
+    sps->log2_diff_max_min_coding_block_size    = get_ue_golomb_long(gb);
+    sps->log2_min_tb_size                       = get_ue_golomb_long(gb) + 2;
+    log2_diff_max_min_transform_block_size      = get_ue_golomb_long(gb);
+    sps->log2_max_trafo_size                    = log2_diff_max_min_transform_block_size + sps->log2_min_tb_size;
+
+    if (sps->log2_min_tb_size >= sps->log2_min_cb_size) {
+        av_log(s->avctx, AV_LOG_ERROR, "Invalid value for log2_min_tb_size");
+        ret = AVERROR_INVALIDDATA;
+        goto err;
+    }
+    sps->max_transform_hierarchy_depth_inter = get_ue_golomb_long(gb);
+    sps->max_transform_hierarchy_depth_intra = get_ue_golomb_long(gb);
+
+    sps->scaling_list_enable_flag = get_bits1(gb);
+    if (sps->scaling_list_enable_flag) {
+        set_default_scaling_list_data(&sps->scaling_list);
+
+        if (get_bits1(gb)) {
+            ret = scaling_list_data(s, &sps->scaling_list);
+            if (ret < 0)
+                goto err;
+        }
+    }
+
+    sps->amp_enabled_flag = get_bits1(gb);
+    sps->sao_enabled      = get_bits1(gb);
+
+    sps->pcm_enabled_flag = get_bits1(gb);
+    if (sps->pcm_enabled_flag) {
+        sps->pcm.bit_depth   = get_bits(gb, 4) + 1;
+        sps->pcm.bit_depth_chroma = get_bits(gb, 4) + 1;
+        sps->pcm.log2_min_pcm_cb_size = get_ue_golomb_long(gb) + 3;
+        sps->pcm.log2_max_pcm_cb_size = sps->pcm.log2_min_pcm_cb_size +
+                                        get_ue_golomb_long(gb);
+        if (sps->pcm.bit_depth > sps->bit_depth) {
+            av_log(s->avctx, AV_LOG_ERROR,
+                   "PCM bit depth (%d) is greater than normal bit depth (%d)\n",
+                   sps->pcm.bit_depth, sps->bit_depth);
+            ret = AVERROR_INVALIDDATA;
+            goto err;
+        }
+
+        sps->pcm.loop_filter_disable_flag = get_bits1(gb);
+    }
+
+    sps->nb_st_rps = get_ue_golomb_long(gb);
+    if (sps->nb_st_rps > MAX_SHORT_TERM_RPS_COUNT) {
+        av_log(s->avctx, AV_LOG_ERROR, "Too many short term RPS: %d.\n",
+               sps->nb_st_rps);
+        ret = AVERROR_INVALIDDATA;
+        goto err;
+    }
+    for (i = 0; i < sps->nb_st_rps; i++) {
+        if ((ret = ff_hevc_decode_short_term_rps(s, &sps->st_rps[i],
+                                                 sps, 0)) < 0)
+            goto err;
+    }
+
+    sps->long_term_ref_pics_present_flag = get_bits1(gb);
+    if (sps->long_term_ref_pics_present_flag) {
+        sps->num_long_term_ref_pics_sps = get_ue_golomb_long(gb);
+        for (i = 0; i < sps->num_long_term_ref_pics_sps; i++) {
+            sps->lt_ref_pic_poc_lsb_sps[i]       = get_bits(gb, sps->log2_max_poc_lsb);
+            sps->used_by_curr_pic_lt_sps_flag[i] = get_bits1(gb);
+        }
+    }
+
+    sps->sps_temporal_mvp_enabled_flag          = get_bits1(gb);
+    sps->sps_strong_intra_smoothing_enable_flag = get_bits1(gb);
+    sps->vui.sar = (AVRational){0, 1};
+    vui_present = get_bits1(gb);
+    if (vui_present)
+        decode_vui(s, sps);
+    skip_bits1(gb); // sps_extension_flag
+
+    if (s->strict_def_disp_win) {
+        sps->output_window.left_offset   += sps->vui.def_disp_win.left_offset;
+        sps->output_window.right_offset  += sps->vui.def_disp_win.right_offset;
+        sps->output_window.top_offset    += sps->vui.def_disp_win.top_offset;
+        sps->output_window.bottom_offset += sps->vui.def_disp_win.bottom_offset;
+    }
+    if (sps->output_window.left_offset & (0x1F >> (sps->pixel_shift))) {
+        sps->output_window.left_offset &= ~(0x1F >> (sps->pixel_shift));
+        av_log(s->avctx, AV_LOG_WARNING, "Reducing left output window to %d "
+               "chroma samples to preserve alignment.\n",
+               sps->output_window.left_offset);
+    }
+    sps->output_width  = sps->width -
+                         (sps->output_window.left_offset + sps->output_window.right_offset);
+    sps->output_height = sps->height -
+                         (sps->output_window.top_offset + sps->output_window.bottom_offset);
+    if (sps->output_width <= 0 || sps->output_height <= 0) {
+        av_log(s->avctx, AV_LOG_WARNING, "Invalid visible frame dimensions: %dx%d.\n",
+               sps->output_width, sps->output_height);
+        //if (s->avctx->err_recognition & AV_EF_EXPLODE) {
+        //    ret = AVERROR_INVALIDDATA;
+        //    goto err;
+        //}
+        av_log(s->avctx, AV_LOG_WARNING, "Displaying the whole video surface.\n");
+        sps->pic_conf_win.left_offset   =
+        sps->pic_conf_win.right_offset  =
+        sps->pic_conf_win.top_offset    =
+        sps->pic_conf_win.bottom_offset = 0;
+        sps->output_width  = sps->width;
+        sps->output_height = sps->height;
+    }
+
+    // Inferred parameters
+    sps->log2_ctb_size     = sps->log2_min_cb_size
+                             + sps->log2_diff_max_min_coding_block_size;
+    sps->log2_min_pu_size  = sps->log2_min_cb_size - 1;
+
+    sps->ctb_width         = (sps->width  + (1 << sps->log2_ctb_size) - 1) >> sps->log2_ctb_size;
+    sps->ctb_height        = (sps->height + (1 << sps->log2_ctb_size) - 1) >> sps->log2_ctb_size;
+    sps->ctb_size          = sps->ctb_width * sps->ctb_height;
+
+    sps->min_cb_width      = sps->width  >> sps->log2_min_cb_size;
+    sps->min_cb_height     = sps->height >> sps->log2_min_cb_size;
+    sps->min_tb_width      = sps->width  >> sps->log2_min_tb_size;
+    sps->min_tb_height     = sps->height >> sps->log2_min_tb_size;
+    sps->min_pu_width      = sps->width  >> sps->log2_min_pu_size;
+    sps->min_pu_height     = sps->height >> sps->log2_min_pu_size;
+
+    sps->qp_bd_offset      = 6 * (sps->bit_depth - 8);
+
+    if (sps->width  & ((1 << sps->log2_min_cb_size) - 1) ||
+        sps->height & ((1 << sps->log2_min_cb_size) - 1)) {
+        av_log(s->avctx, AV_LOG_ERROR, "Invalid coded frame dimensions.\n");
+        goto err;
+    }
+
+    if (sps->log2_ctb_size > MAX_LOG2_CTB_SIZE) {
+        av_log(s->avctx, AV_LOG_ERROR, "CTB size out of range: 2^%d\n", sps->log2_ctb_size);
+        goto err;
+    }
+    if (sps->max_transform_hierarchy_depth_inter > sps->log2_ctb_size - sps->log2_min_tb_size) {
+        av_log(s->avctx, AV_LOG_ERROR, "max_transform_hierarchy_depth_inter out of range: %d\n",
+               sps->max_transform_hierarchy_depth_inter);
+        goto err;
+    }
+    if (sps->max_transform_hierarchy_depth_intra > sps->log2_ctb_size - sps->log2_min_tb_size) {
+        av_log(s->avctx, AV_LOG_ERROR, "max_transform_hierarchy_depth_intra out of range: %d\n",
+               sps->max_transform_hierarchy_depth_intra);
+        goto err;
+    }
+    if (sps->log2_max_trafo_size > FFMIN(sps->log2_ctb_size, 5)) {
+        av_log(s->avctx, AV_LOG_ERROR, "max transform block size out of range: %d\n",
+               sps->log2_max_trafo_size);
+        goto err;
+    }
+
+    if (s->avctx->debug & FF_DEBUG_BITSTREAM) {
+        av_log(s->avctx, AV_LOG_DEBUG, "Parsed SPS: id %d; coded wxh: %dx%d; "
+               "cropped wxh: %dx%d; pix_fmt: %s.\n",
+               sps_id, sps->width, sps->height,
+               sps->output_width, sps->output_height,
+               av_get_pix_fmt_name(sps->pix_fmt));
+    }
+
+    /* check if this is a repeat of an already parsed SPS, then keep the
+     * original one.
+     * otherwise drop all PPSes that depend on it */
+    if (s->sps_list[sps_id] &&
+        !memcmp(s->sps_list[sps_id]->data, sps_buf->data, sps_buf->size)) {
+        av_buffer_unref(&sps_buf);
+    } else {
+        for (i = 0; i < FF_ARRAY_ELEMS(s->pps_list); i++) {
+            if (s->pps_list[i] && ((HEVCPPS*)s->pps_list[i]->data)->sps_id == sps_id)
+                av_buffer_unref(&s->pps_list[i]);
+        }
+        av_buffer_unref(&s->sps_list[sps_id]);
+        s->sps_list[sps_id] = sps_buf;
+    }
+
+    return 0;
+err:
+
+    av_buffer_unref(&sps_buf);
+    return ret;
+}
+
+static void hevc_pps_free(void *opaque, uint8_t *data)
+{
+    HEVCPPS *pps = (HEVCPPS*)data;
+
+    av_freep(&pps->column_width);
+    av_freep(&pps->row_height);
+    av_freep(&pps->col_bd);
+    av_freep(&pps->row_bd);
+    av_freep(&pps->col_idxX);
+    av_freep(&pps->ctb_addr_rs_to_ts);
+    av_freep(&pps->ctb_addr_ts_to_rs);
+    av_freep(&pps->tile_pos_rs);
+    av_freep(&pps->tile_id);
+    av_freep(&pps->min_cb_addr_zs);
+    av_freep(&pps->min_tb_addr_zs);
+
+    av_freep(&pps);
+}
+
+int ff_hevc_decode_nal_pps(HEVCContext *s)
+{
+    GetBitContext *gb = &s->HEVClc->gb;
+    HEVCSPS      *sps = NULL;
+    int pic_area_in_ctbs, pic_area_in_min_cbs, pic_area_in_min_tbs;
+    int log2_diff_ctb_min_tb_size;
+    int i, j, x, y, ctb_addr_rs, tile_id;
+    int ret    = 0;
+    int pps_id = 0;
+
+    AVBufferRef *pps_buf;
+    HEVCPPS *pps = av_mallocz(sizeof(*pps));
+
+    if (!pps)
+        return AVERROR(ENOMEM);
+
+    pps_buf = av_buffer_create((uint8_t*)pps, sizeof(*pps), hevc_pps_free, NULL, 0);
+    if (!pps_buf) {
+        av_freep(&pps);
+        return AVERROR(ENOMEM);
+    }
+
+    av_log(s->avctx, AV_LOG_DEBUG, "Decoding PPS\n");
+
+    // Default values
+    pps->loop_filter_across_tiles_enabled_flag = 1;
+    pps->num_tile_columns                      = 1;
+    pps->num_tile_rows                         = 1;
+    pps->uniform_spacing_flag                  = 1;
+    pps->disable_dbf                           = 0;
+    pps->beta_offset                           = 0;
+    pps->tc_offset                             = 0;
+
+    // Coded parameters
+    pps_id = get_ue_golomb_long(gb);
+    if (pps_id >= MAX_PPS_COUNT) {
+        av_log(s->avctx, AV_LOG_ERROR, "PPS id out of range: %d\n", pps_id);
+        ret = AVERROR_INVALIDDATA;
+        goto err;
+    }
+    pps->sps_id = get_ue_golomb_long(gb);
+    if (pps->sps_id >= MAX_SPS_COUNT) {
+        av_log(s->avctx, AV_LOG_ERROR, "SPS id out of range: %d\n", pps->sps_id);
+        ret = AVERROR_INVALIDDATA;
+        goto err;
+    }
+    if (!s->sps_list[pps->sps_id]) {
+        av_log(s->avctx, AV_LOG_ERROR, "SPS does not exist \n");
+        ret = AVERROR_INVALIDDATA;
+        goto err;
+    }
+    sps = (HEVCSPS*)s->sps_list[pps->sps_id]->data;
+
+    pps->dependent_slice_segments_enabled_flag = get_bits1(gb);
+    pps->output_flag_present_flag              = get_bits1(gb);
+    pps->num_extra_slice_header_bits           = get_bits(gb, 3);
+
+    pps->sign_data_hiding_flag = get_bits1(gb);
+
+    pps->cabac_init_present_flag = get_bits1(gb);
+
+    pps->num_ref_idx_l0_default_active = get_ue_golomb_long(gb) + 1;
+    pps->num_ref_idx_l1_default_active = get_ue_golomb_long(gb) + 1;
+
+    pps->pic_init_qp_minus26 = get_se_golomb(gb);
+
+    pps->constrained_intra_pred_flag = get_bits1(gb);
+    pps->transform_skip_enabled_flag = get_bits1(gb);
+
+    pps->cu_qp_delta_enabled_flag = get_bits1(gb);
+    pps->diff_cu_qp_delta_depth   = 0;
+    if (pps->cu_qp_delta_enabled_flag)
+        pps->diff_cu_qp_delta_depth = get_ue_golomb_long(gb);
+
+    pps->cb_qp_offset = get_se_golomb(gb);
+    if (pps->cb_qp_offset < -12 || pps->cb_qp_offset > 12) {
+        av_log(s->avctx, AV_LOG_ERROR, "pps_cb_qp_offset out of range: %d\n",
+               pps->cb_qp_offset);
+        ret = AVERROR_INVALIDDATA;
+        goto err;
+    }
+    pps->cr_qp_offset = get_se_golomb(gb);
+    if (pps->cr_qp_offset < -12 || pps->cr_qp_offset > 12) {
+        av_log(s->avctx, AV_LOG_ERROR, "pps_cr_qp_offset out of range: %d\n",
+               pps->cr_qp_offset);
+        ret = AVERROR_INVALIDDATA;
+        goto err;
+    }
+    pps->pic_slice_level_chroma_qp_offsets_present_flag = get_bits1(gb);
+
+    pps->weighted_pred_flag   = get_bits1(gb);
+    pps->weighted_bipred_flag = get_bits1(gb);
+
+    pps->transquant_bypass_enable_flag    = get_bits1(gb);
+    pps->tiles_enabled_flag               = get_bits1(gb);
+    pps->entropy_coding_sync_enabled_flag = get_bits1(gb);
+
+    if (pps->tiles_enabled_flag) {
+        pps->num_tile_columns     = get_ue_golomb_long(gb) + 1;
+        pps->num_tile_rows        = get_ue_golomb_long(gb) + 1;
+        if (pps->num_tile_columns == 0 ||
+            pps->num_tile_columns >= sps->width) {
+            av_log(s->avctx, AV_LOG_ERROR, "num_tile_columns_minus1 out of range: %d\n",
+                   pps->num_tile_columns - 1);
+            ret = AVERROR_INVALIDDATA;
+            goto err;
+        }
+        if (pps->num_tile_rows == 0 ||
+            pps->num_tile_rows >= sps->height) {
+            av_log(s->avctx, AV_LOG_ERROR, "num_tile_rows_minus1 out of range: %d\n",
+                   pps->num_tile_rows - 1);
+            ret = AVERROR_INVALIDDATA;
+            goto err;
+        }
+
+        pps->column_width = av_malloc_array(pps->num_tile_columns, sizeof(*pps->column_width));
+        pps->row_height   = av_malloc_array(pps->num_tile_rows,    sizeof(*pps->row_height));
+        if (!pps->column_width || !pps->row_height) {
+            ret = AVERROR(ENOMEM);
+            goto err;
+        }
+
+        pps->uniform_spacing_flag = get_bits1(gb);
+        if (!pps->uniform_spacing_flag) {
+            int sum = 0;
+            for (i = 0; i < pps->num_tile_columns - 1; i++) {
+                pps->column_width[i] = get_ue_golomb_long(gb) + 1;
+                sum += pps->column_width[i];
+            }
+            if (sum >= sps->ctb_width) {
+                av_log(s->avctx, AV_LOG_ERROR, "Invalid tile widths.\n");
+                ret = AVERROR_INVALIDDATA;
+                goto err;
+            }
+            pps->column_width[pps->num_tile_columns - 1] = sps->ctb_width - sum;
+
+            sum = 0;
+            for (i = 0; i < pps->num_tile_rows - 1; i++) {
+                pps->row_height[i] = get_ue_golomb_long(gb) + 1;
+                sum += pps->row_height[i];
+            }
+            if (sum >= sps->ctb_height) {
+                av_log(s->avctx, AV_LOG_ERROR, "Invalid tile heights.\n");
+                ret = AVERROR_INVALIDDATA;
+                goto err;
+            }
+            pps->row_height[pps->num_tile_rows - 1] = sps->ctb_height - sum;
+        }
+        pps->loop_filter_across_tiles_enabled_flag = get_bits1(gb);
+    }
+
+    pps->seq_loop_filter_across_slices_enabled_flag = get_bits1(gb);
+
+    pps->deblocking_filter_control_present_flag = get_bits1(gb);
+    if (pps->deblocking_filter_control_present_flag) {
+        pps->deblocking_filter_override_enabled_flag = get_bits1(gb);
+        pps->disable_dbf = get_bits1(gb);
+        if (!pps->disable_dbf) {
+            pps->beta_offset = get_se_golomb(gb) * 2;
+            pps->tc_offset = get_se_golomb(gb) * 2;
+            if (pps->beta_offset/2 < -6 || pps->beta_offset/2 > 6) {
+                av_log(s->avctx, AV_LOG_ERROR, "pps_beta_offset_div2 out of range: %d\n",
+                       pps->beta_offset/2);
+                ret = AVERROR_INVALIDDATA;
+                goto err;
+            }
+            if (pps->tc_offset/2 < -6 || pps->tc_offset/2 > 6) {
+                av_log(s->avctx, AV_LOG_ERROR, "pps_tc_offset_div2 out of range: %d\n",
+                       pps->tc_offset/2);
+                ret = AVERROR_INVALIDDATA;
+                goto err;
+            }
+        }
+    }
+
+    pps->pps_scaling_list_data_present_flag = get_bits1(gb);
+    if (pps->pps_scaling_list_data_present_flag) {
+        set_default_scaling_list_data(&pps->scaling_list);
+        ret = scaling_list_data(s, &pps->scaling_list);
+        if (ret < 0)
+            goto err;
+    }
+    pps->lists_modification_present_flag = get_bits1(gb);
+    pps->log2_parallel_merge_level       = get_ue_golomb_long(gb) + 2;
+    if (pps->log2_parallel_merge_level > sps->log2_ctb_size) {
+        av_log(s->avctx, AV_LOG_ERROR, "log2_parallel_merge_level_minus2 out of range: %d\n",
+               pps->log2_parallel_merge_level - 2);
+        ret = AVERROR_INVALIDDATA;
+        goto err;
+    }
+
+    pps->slice_header_extension_present_flag = get_bits1(gb);
+    pps->pps_extension_flag                  = get_bits1(gb);
+
+    // Inferred parameters
+    pps->col_bd   = av_malloc_array(pps->num_tile_columns + 1, sizeof(*pps->col_bd));
+    pps->row_bd   = av_malloc_array(pps->num_tile_rows + 1,    sizeof(*pps->row_bd));
+    pps->col_idxX = av_malloc_array(sps->ctb_width,    sizeof(*pps->col_idxX));
+    if (!pps->col_bd || !pps->row_bd || !pps->col_idxX) {
+        ret = AVERROR(ENOMEM);
+        goto err;
+    }
+
+    if (pps->uniform_spacing_flag) {
+        if (!pps->column_width) {
+            pps->column_width = av_malloc_array(pps->num_tile_columns, sizeof(*pps->column_width));
+            pps->row_height   = av_malloc_array(pps->num_tile_rows,    sizeof(*pps->row_height));
+        }
+        if (!pps->column_width || !pps->row_height) {
+            ret = AVERROR(ENOMEM);
+            goto err;
+        }
+
+        for (i = 0; i < pps->num_tile_columns; i++) {
+            pps->column_width[i] = ((i + 1) * sps->ctb_width) / pps->num_tile_columns -
+                                   (i * sps->ctb_width) / pps->num_tile_columns;
+        }
+
+        for (i = 0; i < pps->num_tile_rows; i++) {
+            pps->row_height[i] = ((i + 1) * sps->ctb_height) / pps->num_tile_rows -
+                                 (i * sps->ctb_height) / pps->num_tile_rows;
+        }
+    }
+
+    pps->col_bd[0] = 0;
+    for (i = 0; i < pps->num_tile_columns; i++)
+        pps->col_bd[i + 1] = pps->col_bd[i] + pps->column_width[i];
+
+    pps->row_bd[0] = 0;
+    for (i = 0; i < pps->num_tile_rows; i++)
+        pps->row_bd[i + 1] = pps->row_bd[i] + pps->row_height[i];
+
+    for (i = 0, j = 0; i < sps->ctb_width; i++) {
+         if (i > pps->col_bd[j])
+             j++;
+         pps->col_idxX[i] = j;
+    }
+
+    /**
+     * 6.5
+     */
+    pic_area_in_ctbs     = sps->ctb_width    * sps->ctb_height;
+    pic_area_in_min_cbs  = sps->min_cb_width * sps->min_cb_height;
+    pic_area_in_min_tbs  = sps->min_tb_width * sps->min_tb_height;
+
+    pps->ctb_addr_rs_to_ts = av_malloc_array(pic_area_in_ctbs,    sizeof(*pps->ctb_addr_rs_to_ts));
+    pps->ctb_addr_ts_to_rs = av_malloc_array(pic_area_in_ctbs,    sizeof(*pps->ctb_addr_ts_to_rs));
+    pps->tile_id           = av_malloc_array(pic_area_in_ctbs,    sizeof(*pps->tile_id));
+    pps->min_cb_addr_zs    = av_malloc_array(pic_area_in_min_cbs, sizeof(*pps->min_cb_addr_zs));
+    pps->min_tb_addr_zs    = av_malloc_array(pic_area_in_min_tbs, sizeof(*pps->min_tb_addr_zs));
+    if (!pps->ctb_addr_rs_to_ts || !pps->ctb_addr_ts_to_rs ||
+        !pps->tile_id || !pps->min_cb_addr_zs || !pps->min_tb_addr_zs) {
+        ret = AVERROR(ENOMEM);
+        goto err;
+    }
+
+    for (ctb_addr_rs = 0; ctb_addr_rs < pic_area_in_ctbs; ctb_addr_rs++) {
+        int tb_x   = ctb_addr_rs % sps->ctb_width;
+        int tb_y   = ctb_addr_rs / sps->ctb_width;
+        int tile_x = 0;
+        int tile_y = 0;
+        int val    = 0;
+
+        for (i = 0; i < pps->num_tile_columns; i++) {
+            if (tb_x < pps->col_bd[i + 1]) {
+                tile_x = i;
+                break;
+            }
+        }
+
+        for (i = 0; i < pps->num_tile_rows; i++) {
+            if (tb_y < pps->row_bd[i + 1]) {
+                tile_y = i;
+                break;
+            }
+        }
+
+        for (i = 0; i < tile_x; i++ )
+            val += pps->row_height[tile_y] * pps->column_width[i];
+        for (i = 0; i < tile_y; i++ )
+            val += sps->ctb_width * pps->row_height[i];
+
+        val += (tb_y - pps->row_bd[tile_y]) * pps->column_width[tile_x] +
+               tb_x - pps->col_bd[tile_x];
+
+        pps->ctb_addr_rs_to_ts[ctb_addr_rs] = val;
+        pps->ctb_addr_ts_to_rs[val] = ctb_addr_rs;
+    }
+
+    for (j = 0, tile_id = 0; j < pps->num_tile_rows; j++)
+        for (i = 0; i < pps->num_tile_columns; i++, tile_id++)
+            for (y = pps->row_bd[j]; y < pps->row_bd[j + 1]; y++)
+                for (x = pps->col_bd[i]; x < pps->col_bd[i + 1]; x++)
+                    pps->tile_id[pps->ctb_addr_rs_to_ts[y * sps->ctb_width + x]] = tile_id;
+
+    pps->tile_pos_rs = av_malloc_array(tile_id, sizeof(*pps->tile_pos_rs));
+    if (!pps->tile_pos_rs) {
+        ret = AVERROR(ENOMEM);
+        goto err;
+    }
+
+    for (j = 0; j < pps->num_tile_rows; j++)
+        for (i = 0; i < pps->num_tile_columns; i++)
+            pps->tile_pos_rs[j * pps->num_tile_columns + i] = pps->row_bd[j] * sps->ctb_width + pps->col_bd[i];
+
+    for (y = 0; y < sps->min_cb_height; y++) {
+        for (x = 0; x < sps->min_cb_width; x++) {
+            int tb_x = x >> sps->log2_diff_max_min_coding_block_size;
+            int tb_y = y >> sps->log2_diff_max_min_coding_block_size;
+            int ctb_addr_rs = sps->ctb_width * tb_y + tb_x;
+            int val = pps->ctb_addr_rs_to_ts[ctb_addr_rs] <<
+                      (sps->log2_diff_max_min_coding_block_size * 2);
+            for (i = 0; i < sps->log2_diff_max_min_coding_block_size; i++) {
+                int m = 1 << i;
+                val += (m & x ? m * m : 0) + (m & y ? 2 * m * m : 0);
+            }
+            pps->min_cb_addr_zs[y * sps->min_cb_width + x] = val;
+        }
+    }
+
+    log2_diff_ctb_min_tb_size = sps->log2_ctb_size - sps->log2_min_tb_size;
+    for (y = 0; y < sps->min_tb_height; y++) {
+        for (x = 0; x < sps->min_tb_width; x++) {
+            int tb_x = x >> log2_diff_ctb_min_tb_size;
+            int tb_y = y >> log2_diff_ctb_min_tb_size;
+            int ctb_addr_rs = sps->ctb_width * tb_y + tb_x;
+            int val = pps->ctb_addr_rs_to_ts[ctb_addr_rs] <<
+                      (log2_diff_ctb_min_tb_size * 2);
+            for (i = 0; i < log2_diff_ctb_min_tb_size; i++) {
+                int m = 1 << i;
+                val += (m & x ? m * m : 0) + (m & y ? 2 * m * m : 0);
+            }
+            pps->min_tb_addr_zs[y * sps->min_tb_width + x] = val;
+        }
+    }
+
+    av_buffer_unref(&s->pps_list[pps_id]);
+    s->pps_list[pps_id] = pps_buf;
+
+    return 0;
+
+err:
+    av_buffer_unref(&pps_buf);
+    return ret;
+}
+
+
+static int HEVC_getNextNALUnit(
+        const uint8_t **_data, size_t *_size,
+        const uint8_t **nalStart, size_t *nalSize,
+        int startCodeFollows) {
+    const uint8_t *data = *_data;
+    size_t size = *_size;
+
+    *nalStart = NULL;
+    *nalSize = 0;
+
+    if (size == 0) {
+        return -1;
+    }
+
+    // Skip any number of leading 0x00.
+
+    size_t offset = 0;
+    while (offset < size && data[offset] == 0x00) {
+        ++offset;
+    }
+
+    if (offset == size) {
+        return -1;
+    }
+
+    // A valid startcode consists of at least two 0x00 bytes followed by 0x01.
+
+    if (offset < 2 || data[offset] != 0x01) {
+        return -1;
+    }
+
+    ++offset;
+
+    size_t startOffset = offset;
+
+    for (;;) {
+        while (offset < size && data[offset] != 0x01) {
+            ++offset;
+        }
+
+        if (offset == size) {
+            if (startCodeFollows == 1) {
+                offset = size + 2;
+                break;
+            }
+
+            return -1;
+        }
+
+        if (data[offset - 1] == 0x00 && data[offset - 2] == 0x00) {
+            break;
+        }
+
+        ++offset;
+    }
+
+    size_t endOffset = offset - 2;
+    while (endOffset > startOffset + 1 && data[endOffset - 1] == 0x00) {
+        --endOffset;
+    }
+
+    *nalStart = &data[startOffset];
+    *nalSize = endOffset - startOffset;
+
+    if (offset + 2 < size) {
+        *_data = &data[offset - 2];
+        *_size = size - offset + 2;
+    } else {
+        *_data = NULL;
+        *_size = 0;
+    }
+
+    return 0;
+}
+
+
+int HEVC_decode_SPS(const uint8_t *buf,int size,struct hevc_info*info)
+{
+	HEVCContext s;
+	AVCodecContext avctx;
+	HEVCLocalContext HEVClc;
+	memset(&s,0,sizeof(s));
+	memset(&avctx,0,sizeof(avctx));
+	memset(&HEVClc,0,sizeof(HEVClc));
+	s.avctx=&avctx;
+	s.HEVClc=&HEVClc;
+	HEVCNAL nal;
+	memset(&nal,0,sizeof(nal));
+       const uint8_t *nalStart;
+       int nalsize;
+       while(!HEVC_getNextNALUnit(&buf, &size, &nalStart, &nalsize, 1)){
+           if (((nalStart[0]>>1) & 0x3f) == 33) { //SPS
+               nalStart += 2;
+               nalsize -= 2;
+               ff_hevc_extract_rbsp(&s,nalStart,nalsize,&nal);
+	        init_get_bits8(&s.HEVClc->gb,nal.data, nal.size);
+	        int err=ff_hevc_decode_nal_sps(&s);
+
+	       if(s.sps_list[0])
+	       {
+		    HEVCSPS *sps = (HEVCSPS*)s.sps_list[0]->data;
+		    info->mwidth=sps->width;
+		    info->mheight=sps->height;
+	       }else{
+		    return -1;
+	       }
+	       return 0;
+           }
+      }
+      return -1;
+}
+
+
+////////////////// sei /////////////////////////
+static void decode_nal_sei_decoded_picture_hash(HEVCContext *s, int payload_size)
+{
+    int cIdx, i;
+    uint8_t hash_type;
+    //uint16_t picture_crc;
+    //uint32_t picture_checksum;
+    GetBitContext *gb = &s->HEVClc->gb;
+    hash_type = get_bits(gb, 8);
+
+
+    for( cIdx = 0; cIdx < 3/*((s->sps->chroma_format_idc == 0) ? 1 : 3)*/; cIdx++ ) {
+        if ( hash_type == 0 ) {
+            s->is_md5 = 1;
+            for( i = 0; i < 16; i++) {
+                s->md5[cIdx][i] = get_bits(gb, 8);
+            }
+        } else if( hash_type == 1 ) {
+            // picture_crc = get_bits(gb, 16);
+            skip_bits(gb, 16);
+        } else if( hash_type == 2 ) {
+            // picture_checksum = get_bits(gb, 32);
+            skip_bits(gb, 32);
+        }
+    }
+}
+
+static void decode_nal_sei_frame_packing_arrangement(HEVCLocalContext *lc)
+{
+    GetBitContext *gb = &lc->gb;
+    int cancel, type, quincunx;
+
+    get_ue_golomb(gb);                      // frame_packing_arrangement_id
+    cancel = get_bits1(gb);                 // frame_packing_cancel_flag
+    if ( cancel == 0 )
+    {
+        type = get_bits(gb, 7);             // frame_packing_arrangement_type
+        quincunx = get_bits1(gb);           // quincunx_sampling_flag
+        skip_bits(gb, 6);                   // content_interpretation_type
+
+        // the following skips spatial_flipping_flag frame0_flipped_flag
+        // field_views_flag current_frame_is_frame0_flag
+        // frame0_self_contained_flag frame1_self_contained_flag
+        skip_bits(gb, 6);
+
+        if ( quincunx == 0 && type != 5 )
+            skip_bits(gb, 16);              // frame[01]_grid_position_[xy]
+        skip_bits(gb, 8);                   // frame_packing_arrangement_reserved_byte
+        skip_bits1(gb);                     // frame_packing_arrangement_persistance_flag
+    }
+    skip_bits1(gb);                         // upsampled_aspect_ratio_flag
+}
+
+static int decode_nal_sei_message(HEVCContext *s)
+{
+    GetBitContext *gb = &s->HEVClc->gb;
+
+    int payload_type = 0;
+    int payload_size = 0;
+    int byte = 0xFF;
+    av_log(s->avctx, AV_LOG_DEBUG, "Decoding SEI\n");
+
+    while (byte == 0xFF) {
+        byte = get_bits(gb, 8);
+        payload_type += byte;
+    }
+    byte = 0xFF;
+    while (byte == 0xFF) {
+        byte = get_bits(gb, 8);
+        payload_size += byte;
+    }
+    if (s->nal_unit_type == NAL_SEI_PREFIX) {
+        if (payload_type == 256 /*&& s->decode_checksum_sei*/)
+            decode_nal_sei_decoded_picture_hash(s, payload_size);
+        else if (payload_type == 45)
+            decode_nal_sei_frame_packing_arrangement(s->HEVClc);
+        else {
+            av_log(s->avctx, AV_LOG_DEBUG, "Skipped PREFIX SEI %d\n", payload_type);
+            skip_bits(gb, 8*payload_size);
+        }
+    } else { /* nal_unit_type == NAL_SEI_SUFFIX */
+        if (payload_type == 132 /* && s->decode_checksum_sei */)
+            decode_nal_sei_decoded_picture_hash(s, payload_size);
+        else {
+            av_log(s->avctx, AV_LOG_DEBUG, "Skipped SUFFIX SEI %d\n", payload_type);
+            skip_bits(gb, 8*payload_size);
+        }
+    }
+    return 0;
+}
+
+static int more_rbsp_data(GetBitContext *gb)
+{
+    return get_bits_left(gb) > 0 && show_bits(gb, 8) != 0x80;
+}
+
+int ff_hevc_decode_nal_sei(HEVCContext *s)
+{
+    do {
+        decode_nal_sei_message(s);
+    } while (more_rbsp_data(&s->HEVClc->gb));
+    return 0;
+}
diff --git a/amffmpeg/libavcodec/hevc.h b/amffmpeg/libavcodec/hevc.h
new file mode 100644
index 0000000..32dffaf
--- /dev/null
+++ b/amffmpeg/libavcodec/hevc.h
@@ -0,0 +1,977 @@
+/*
+ * HEVC video Decoder
+ *
+ * Copyright (C) 2012 - 2013 Guillaume Martres
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifndef AVCODEC_HEVC_H
+#define AVCODEC_HEVC_H
+
+#include "libavutil/md5.h"
+
+#include "avcodec.h"
+#include "cabac.h"
+#include "get_bits.h"
+#include "internal.h"
+
+#define MAX_DPB_SIZE 16 // A.4.1
+#define MAX_REFS 16
+
+#define MAX_NB_THREADS 16
+#define SHIFT_CTB_WPP 2
+
+/**
+ * 7.4.2.1
+ */
+#define MAX_SUB_LAYERS 7
+#define MAX_VPS_COUNT 16
+#define MAX_SPS_COUNT 32
+#define MAX_PPS_COUNT 256
+#define MAX_SHORT_TERM_RPS_COUNT 64
+#define MAX_CU_SIZE 128
+
+//TODO: check if this is really the maximum
+#define MAX_TRANSFORM_DEPTH 5
+
+#define MAX_TB_SIZE 32
+#define MAX_PB_SIZE 64
+#define MAX_LOG2_CTB_SIZE 6
+#define MAX_QP 51
+#define DEFAULT_INTRA_TC_OFFSET 2
+
+#define HEVC_CONTEXTS 183
+
+#define MRG_MAX_NUM_CANDS     5
+
+#define L0 0
+#define L1 1
+
+#define EPEL_EXTRA_BEFORE 1
+#define EPEL_EXTRA_AFTER  2
+#define EPEL_EXTRA        3
+
+/**
+ * Value of the luma sample at position (x, y) in the 2D array tab.
+ */
+#define SAMPLE(tab, x, y) ((tab)[(y) * s->sps->width + (x)])
+#define SAMPLE_CTB(tab, x, y) ((tab)[(y) * min_cb_width + (x)])
+#define SAMPLE_CBF(tab, x, y) ((tab)[((y) & ((1<<log2_trafo_size)-1)) * MAX_CU_SIZE + ((x) & ((1<<log2_trafo_size)-1))])
+
+#define IS_IDR(s) (s->nal_unit_type == NAL_IDR_W_RADL || s->nal_unit_type == NAL_IDR_N_LP)
+#define IS_BLA(s) (s->nal_unit_type == NAL_BLA_W_RADL || s->nal_unit_type == NAL_BLA_W_LP || \
+                   s->nal_unit_type == NAL_BLA_N_LP)
+#define IS_IRAP(s) (s->nal_unit_type >= 16 && s->nal_unit_type <= 23)
+
+/**
+ * Table 7-3: NAL unit type codes
+ */
+enum NALUnitType {
+    NAL_TRAIL_N     =  0,
+    NAL_TRAIL_R     =  1,
+    NAL_TSA_N       =  2,
+    NAL_TSA_R       =  3,
+    NAL_STSA_N      =  4,
+    NAL_STSA_R      =  5,
+    NAL_RADL_N      =  6,
+    NAL_RADL_R      =  7,
+    NAL_RASL_N      =  8,
+    NAL_RASL_R      =  9,
+    NAL_BLA_W_LP    = 16,
+    NAL_BLA_W_RADL  = 17,
+    NAL_BLA_N_LP    = 18,
+    NAL_IDR_W_RADL  = 19,
+    NAL_IDR_N_LP    = 20,
+    NAL_CRA_NUT     = 21,
+    NAL_VPS         = 32,
+    NAL_SPS         = 33,
+    NAL_PPS         = 34,
+    NAL_AUD         = 35,
+    NAL_EOS_NUT     = 36,
+    NAL_EOB_NUT     = 37,
+    NAL_FD_NUT      = 38,
+    NAL_SEI_PREFIX  = 39,
+    NAL_SEI_SUFFIX  = 40,
+};
+
+enum RPSType {
+    ST_CURR_BEF = 0,
+    ST_CURR_AFT,
+    ST_FOLL,
+    LT_CURR,
+    LT_FOLL,
+    NB_RPS_TYPE,
+};
+
+enum SliceType {
+    B_SLICE = 0,
+    P_SLICE = 1,
+    I_SLICE = 2,
+};
+
+enum SyntaxElement {
+    SAO_MERGE_FLAG = 0,
+    SAO_TYPE_IDX,
+    SAO_EO_CLASS,
+    SAO_BAND_POSITION,
+    SAO_OFFSET_ABS,
+    SAO_OFFSET_SIGN,
+    END_OF_SLICE_FLAG,
+    SPLIT_CODING_UNIT_FLAG,
+    CU_TRANSQUANT_BYPASS_FLAG,
+    SKIP_FLAG,
+    CU_QP_DELTA,
+    PRED_MODE_FLAG,
+    PART_MODE,
+    PCM_FLAG,
+    PREV_INTRA_LUMA_PRED_FLAG,
+    MPM_IDX,
+    REM_INTRA_LUMA_PRED_MODE,
+    INTRA_CHROMA_PRED_MODE,
+    MERGE_FLAG,
+    MERGE_IDX,
+    INTER_PRED_IDC,
+    REF_IDX_L0,
+    REF_IDX_L1,
+    ABS_MVD_GREATER0_FLAG,
+    ABS_MVD_GREATER1_FLAG,
+    ABS_MVD_MINUS2,
+    MVD_SIGN_FLAG,
+    MVP_LX_FLAG,
+    NO_RESIDUAL_DATA_FLAG,
+    SPLIT_TRANSFORM_FLAG,
+    CBF_LUMA,
+    CBF_CB_CR,
+    TRANSFORM_SKIP_FLAG,
+    LAST_SIGNIFICANT_COEFF_X_PREFIX,
+    LAST_SIGNIFICANT_COEFF_Y_PREFIX,
+    LAST_SIGNIFICANT_COEFF_X_SUFFIX,
+    LAST_SIGNIFICANT_COEFF_Y_SUFFIX,
+    SIGNIFICANT_COEFF_GROUP_FLAG,
+    SIGNIFICANT_COEFF_FLAG,
+    COEFF_ABS_LEVEL_GREATER1_FLAG,
+    COEFF_ABS_LEVEL_GREATER2_FLAG,
+    COEFF_ABS_LEVEL_REMAINING,
+    COEFF_SIGN_FLAG,
+};
+
+enum PartMode {
+    PART_2Nx2N = 0,
+    PART_2NxN  = 1,
+    PART_Nx2N  = 2,
+    PART_NxN   = 3,
+    PART_2NxnU = 4,
+    PART_2NxnD = 5,
+    PART_nLx2N = 6,
+    PART_nRx2N = 7,
+};
+
+enum PredMode {
+    MODE_INTER = 0,
+    MODE_INTRA,
+    MODE_SKIP,
+};
+
+enum InterPredIdc {
+    PRED_L0 = 0,
+    PRED_L1,
+    PRED_BI,
+};
+
+enum IntraPredMode {
+    INTRA_PLANAR = 0,
+    INTRA_DC,
+    INTRA_ANGULAR_2,
+    INTRA_ANGULAR_3,
+    INTRA_ANGULAR_4,
+    INTRA_ANGULAR_5,
+    INTRA_ANGULAR_6,
+    INTRA_ANGULAR_7,
+    INTRA_ANGULAR_8,
+    INTRA_ANGULAR_9,
+    INTRA_ANGULAR_10,
+    INTRA_ANGULAR_11,
+    INTRA_ANGULAR_12,
+    INTRA_ANGULAR_13,
+    INTRA_ANGULAR_14,
+    INTRA_ANGULAR_15,
+    INTRA_ANGULAR_16,
+    INTRA_ANGULAR_17,
+    INTRA_ANGULAR_18,
+    INTRA_ANGULAR_19,
+    INTRA_ANGULAR_20,
+    INTRA_ANGULAR_21,
+    INTRA_ANGULAR_22,
+    INTRA_ANGULAR_23,
+    INTRA_ANGULAR_24,
+    INTRA_ANGULAR_25,
+    INTRA_ANGULAR_26,
+    INTRA_ANGULAR_27,
+    INTRA_ANGULAR_28,
+    INTRA_ANGULAR_29,
+    INTRA_ANGULAR_30,
+    INTRA_ANGULAR_31,
+    INTRA_ANGULAR_32,
+    INTRA_ANGULAR_33,
+    INTRA_ANGULAR_34,
+};
+
+enum SAOType {
+    SAO_NOT_APPLIED = 0,
+    SAO_BAND,
+    SAO_EDGE,
+};
+
+enum SAOEOClass {
+    SAO_EO_HORIZ = 0,
+    SAO_EO_VERT,
+    SAO_EO_135D,
+    SAO_EO_45D,
+};
+
+enum ScanType {
+    SCAN_DIAG = 0,
+    SCAN_HORIZ,
+    SCAN_VERT,
+};
+
+////////////// buffer ////////////////
+typedef struct AVBuffer AVBuffer;
+struct AVBuffer {
+    uint8_t *data; /**< data described by this buffer */
+    int      size; /**< size of data in bytes */
+
+    /**
+     *  number of existing AVBufferRef instances referring to this buffer
+     */
+    volatile int refcount;
+
+    /**
+     * a callback for freeing the data
+     */
+    void (*free)(void *opaque, uint8_t *data);
+
+    /**
+     * an opaque pointer, to be used by the freeing callback
+     */
+    void *opaque;
+
+    /**
+     * A combination of BUFFER_FLAG_*
+     */
+    int flags;
+};
+
+typedef struct AVBufferPool AVBufferPool;
+
+typedef struct AVBufferRef {
+    AVBuffer *buffer;
+
+    /**
+     * The data buffer. It is considered writable if and only if
+     * this is the only reference to the buffer, in which case
+     * av_buffer_is_writable() returns 1.
+     */
+    uint8_t *data;
+    /**
+     * Size of data in bytes.
+     */
+    int      size;
+} AVBufferRef;
+
+typedef struct BufferPoolEntry {
+    uint8_t *data;
+
+    /*
+     * Backups of the original opaque/free of the AVBuffer corresponding to
+     * data. They will be used to free the buffer when the pool is freed.
+     */
+    void *opaque;
+    void (*free)(void *opaque, uint8_t *data);
+
+    AVBufferPool *pool;
+    struct BufferPoolEntry * volatile next;
+} BufferPoolEntry;
+
+struct AVBufferPool {
+    BufferPoolEntry * volatile pool;
+
+    /*
+     * This is used to track when the pool is to be freed.
+     * The pointer to the pool itself held by the caller is considered to
+     * be one reference. Each buffer requested by the caller increases refcount
+     * by one, returning the buffer to the pool decreases it by one.
+     * refcount reaches zero when the buffer has been uninited AND all the
+     * buffers have been released, then it's safe to free the pool and all
+     * the buffers in it.
+     */
+    volatile int refcount;
+
+    volatile int nb_allocated;
+
+    int size;
+    AVBufferRef* (*alloc)(int size);
+};
+
+void av_buffer_unref(AVBufferRef **buf);
+/////////////////////////////////////////
+
+typedef struct ShortTermRPS {
+    int num_negative_pics;
+    int num_delta_pocs;
+    int32_t delta_poc[32];
+    uint8_t used[32];
+} ShortTermRPS;
+
+typedef struct LongTermRPS {
+    int     poc[32];
+    uint8_t used[32];
+    uint8_t nb_refs;
+} LongTermRPS;
+
+typedef struct RefPicList {
+    struct HEVCFrame *ref[MAX_REFS];
+    int list[MAX_REFS];
+    int isLongTerm[MAX_REFS];
+    int nb_refs;
+} RefPicList;
+
+typedef struct RefPicListTab {
+    RefPicList refPicList[2];
+} RefPicListTab;
+
+typedef struct HEVCWindow {
+    int left_offset;
+    int right_offset;
+    int top_offset;
+    int bottom_offset;
+} HEVCWindow;
+
+typedef struct VUI {
+    AVRational sar;
+
+    int overscan_info_present_flag;
+    int overscan_appropriate_flag;
+
+    int video_signal_type_present_flag;
+    int video_format;
+    int video_full_range_flag;
+    int colour_description_present_flag;
+    uint8_t colour_primaries;
+    uint8_t transfer_characteristic;
+    uint8_t matrix_coeffs;
+
+    int chroma_loc_info_present_flag;
+    int chroma_sample_loc_type_top_field;
+    int chroma_sample_loc_type_bottom_field;
+    int neutra_chroma_indication_flag;
+
+    int field_seq_flag;
+    int frame_field_info_present_flag;
+
+    int default_display_window_flag;
+    HEVCWindow def_disp_win;
+
+    int vui_timing_info_present_flag;
+    uint32_t vui_num_units_in_tick;
+    uint32_t vui_time_scale;
+    int vui_poc_proportional_to_timing_flag;
+    int vui_num_ticks_poc_diff_one_minus1;
+    int vui_hrd_parameters_present_flag;
+
+    int bitstream_restriction_flag;
+    int tiles_fixed_structure_flag;
+    int motion_vectors_over_pic_boundaries_flag;
+    int restricted_ref_pic_lists_flag;
+    int min_spatial_segmentation_idc;
+    int max_bytes_per_pic_denom;
+    int max_bits_per_min_cu_denom;
+    int log2_max_mv_length_horizontal;
+    int log2_max_mv_length_vertical;
+} VUI;
+
+typedef struct PTL {
+    int general_profile_space;
+    uint8_t general_tier_flag;
+    int general_profile_idc;
+    int general_profile_compatibility_flag[32];
+    int general_level_idc;
+
+    uint8_t sub_layer_profile_present_flag[MAX_SUB_LAYERS];
+    uint8_t sub_layer_level_present_flag[MAX_SUB_LAYERS];
+
+    int sub_layer_profile_space[MAX_SUB_LAYERS];
+    uint8_t sub_layer_tier_flag[MAX_SUB_LAYERS];
+    int sub_layer_profile_idc[MAX_SUB_LAYERS];
+    uint8_t sub_layer_profile_compatibility_flags[MAX_SUB_LAYERS][32];
+    int sub_layer_level_idc[MAX_SUB_LAYERS];
+} PTL;
+
+typedef struct VPS {
+    uint8_t vps_temporal_id_nesting_flag;
+    int vps_max_layers;
+    int vps_max_sub_layers; ///< vps_max_temporal_layers_minus1 + 1
+
+    PTL ptl;
+    int vps_sub_layer_ordering_info_present_flag;
+    unsigned int vps_max_dec_pic_buffering[MAX_SUB_LAYERS];
+    unsigned int vps_num_reorder_pics[MAX_SUB_LAYERS];
+    unsigned int vps_max_latency_increase[MAX_SUB_LAYERS];
+    int vps_max_layer_id;
+    int vps_num_layer_sets; ///< vps_num_layer_sets_minus1 + 1
+    uint8_t vps_timing_info_present_flag;
+    uint32_t vps_num_units_in_tick;
+    uint32_t vps_time_scale;
+    uint8_t vps_poc_proportional_to_timing_flag;
+    int vps_num_ticks_poc_diff_one; ///< vps_num_ticks_poc_diff_one_minus1 + 1
+    int vps_num_hrd_parameters;
+} VPS;
+
+typedef struct ScalingList {
+    // This is a little wasteful, since sizeID 0 only needs 8 coeffs, and size ID 3 only has 2 arrays, not 6.
+    uint8_t sl[4][6][64];
+    uint8_t sl_dc[2][6];
+} ScalingList;
+
+typedef struct HEVCSPS {
+    int vps_id;
+    int chroma_format_idc;
+    uint8_t separate_colour_plane_flag;
+
+    ///< output (i.e. cropped) values
+    int output_width, output_height;
+    HEVCWindow output_window;
+
+    HEVCWindow pic_conf_win;
+
+    int bit_depth;
+    int pixel_shift;
+    enum PixelFormat pix_fmt;
+
+    unsigned int log2_max_poc_lsb;
+    int pcm_enabled_flag;
+
+    int max_sub_layers;
+    struct {
+        int max_dec_pic_buffering;
+        int num_reorder_pics;
+        int max_latency_increase;
+    } temporal_layer[MAX_SUB_LAYERS];
+
+    VUI vui;
+    PTL ptl;
+
+    uint8_t scaling_list_enable_flag;
+    ScalingList scaling_list;
+
+    unsigned int nb_st_rps;
+    ShortTermRPS st_rps[MAX_SHORT_TERM_RPS_COUNT];
+
+    uint8_t amp_enabled_flag;
+    uint8_t sao_enabled;
+
+    uint8_t long_term_ref_pics_present_flag;
+    uint16_t lt_ref_pic_poc_lsb_sps[32];
+    uint8_t used_by_curr_pic_lt_sps_flag[32];
+    uint8_t num_long_term_ref_pics_sps;
+
+    struct {
+        uint8_t bit_depth;
+        uint8_t bit_depth_chroma;
+        unsigned int log2_min_pcm_cb_size;
+        unsigned int log2_max_pcm_cb_size;
+        uint8_t loop_filter_disable_flag;
+    } pcm;
+    uint8_t sps_temporal_mvp_enabled_flag;
+    uint8_t sps_strong_intra_smoothing_enable_flag;
+
+    unsigned int log2_min_cb_size;
+    unsigned int log2_diff_max_min_coding_block_size;
+    unsigned int log2_min_tb_size;
+    unsigned int log2_max_trafo_size;
+    unsigned int log2_ctb_size;
+    unsigned int log2_min_pu_size;
+
+    int max_transform_hierarchy_depth_inter;
+    int max_transform_hierarchy_depth_intra;
+
+    ///< coded frame dimension in various units
+    int width;
+    int height;
+    int ctb_width;
+    int ctb_height;
+    int ctb_size;
+    int min_cb_width;
+    int min_cb_height;
+    int min_tb_width;
+    int min_tb_height;
+    int min_pu_width;
+    int min_pu_height;
+
+    int hshift[3];
+    int vshift[3];
+
+    int qp_bd_offset;
+} HEVCSPS;
+
+typedef struct HEVCPPS {
+    int sps_id; ///< seq_parameter_set_id
+
+    uint8_t sign_data_hiding_flag;
+
+    uint8_t cabac_init_present_flag;
+
+    int num_ref_idx_l0_default_active; ///< num_ref_idx_l0_default_active_minus1 + 1
+    int num_ref_idx_l1_default_active; ///< num_ref_idx_l1_default_active_minus1 + 1
+    int pic_init_qp_minus26;
+
+    uint8_t constrained_intra_pred_flag;
+    uint8_t transform_skip_enabled_flag;
+
+    uint8_t cu_qp_delta_enabled_flag;
+    int diff_cu_qp_delta_depth;
+
+    int cb_qp_offset;
+    int cr_qp_offset;
+    uint8_t pic_slice_level_chroma_qp_offsets_present_flag;
+    uint8_t weighted_pred_flag;
+    uint8_t weighted_bipred_flag;
+    uint8_t output_flag_present_flag;
+    uint8_t transquant_bypass_enable_flag;
+
+    uint8_t dependent_slice_segments_enabled_flag;
+    uint8_t tiles_enabled_flag;
+    uint8_t entropy_coding_sync_enabled_flag;
+
+    int num_tile_columns; ///< num_tile_columns_minus1 + 1
+    int num_tile_rows; ///< num_tile_rows_minus1 + 1
+    uint8_t uniform_spacing_flag;
+    uint8_t loop_filter_across_tiles_enabled_flag;
+
+    uint8_t seq_loop_filter_across_slices_enabled_flag;
+
+    uint8_t deblocking_filter_control_present_flag;
+    uint8_t deblocking_filter_override_enabled_flag;
+    uint8_t disable_dbf;
+    int beta_offset; ///< beta_offset_div2 * 2
+    int tc_offset; ///< tc_offset_div2 * 2
+
+    int pps_scaling_list_data_present_flag;
+    ScalingList scaling_list;
+
+    uint8_t lists_modification_present_flag;
+    int log2_parallel_merge_level; ///< log2_parallel_merge_level_minus2 + 2
+    int num_extra_slice_header_bits;
+    uint8_t slice_header_extension_present_flag;
+
+    uint8_t pps_extension_flag;
+    uint8_t pps_extension_data_flag;
+
+    // Inferred parameters
+    int *column_width; ///< ColumnWidth
+    int *row_height; ///< RowHeight
+    int *col_bd; ///< ColBd
+    int *row_bd; ///< RowBd
+    int *col_idxX;
+
+    int *ctb_addr_rs_to_ts; ///< CtbAddrRSToTS
+    int *ctb_addr_ts_to_rs; ///< CtbAddrTSToRS
+    int *tile_id; ///< TileId
+    int *tile_pos_rs; ///< TilePosRS
+    int *min_cb_addr_zs; ///< MinCbAddrZS
+    int *min_tb_addr_zs; ///< MinTbAddrZS
+} HEVCPPS;
+
+typedef struct SliceHeader {
+    int pps_id;
+
+    ///< address (in raster order) of the first block in the current slice segment
+    unsigned int   slice_segment_addr;
+    ///< address (in raster order) of the first block in the current slice
+    unsigned int   slice_addr;
+
+    enum SliceType slice_type;
+
+    int pic_order_cnt_lsb;
+
+    uint8_t first_slice_in_pic_flag;
+    uint8_t dependent_slice_segment_flag;
+    uint8_t pic_output_flag;
+    uint8_t colour_plane_id;
+
+    ///< RPS coded in the slice header itself is stored here
+    ShortTermRPS slice_rps;
+    const ShortTermRPS *short_term_rps;
+    LongTermRPS long_term_rps;
+    unsigned int list_entry_lx[2][32];
+
+    uint8_t rpl_modification_flag[2];
+    uint8_t no_output_of_prior_pics_flag;
+    uint8_t slice_temporal_mvp_enabled_flag;
+
+    unsigned int nb_refs[2];
+
+    uint8_t slice_sample_adaptive_offset_flag[3];
+    uint8_t mvd_l1_zero_flag;
+
+    uint8_t cabac_init_flag;
+    uint8_t disable_deblocking_filter_flag; ///< slice_header_disable_deblocking_filter_flag
+    uint8_t slice_loop_filter_across_slices_enabled_flag;
+    uint8_t collocated_list;
+
+    unsigned int collocated_ref_idx;
+
+    int slice_qp_delta;
+    int slice_cb_qp_offset;
+    int slice_cr_qp_offset;
+
+    int beta_offset; ///< beta_offset_div2 * 2
+    int tc_offset; ///< tc_offset_div2 * 2
+
+    int max_num_merge_cand; ///< 5 - 5_minus_max_num_merge_cand
+
+
+    int *entry_point_offset;
+    int * offset;
+    int * size;
+    int num_entry_point_offsets;
+
+    int8_t slice_qp;
+
+    uint8_t luma_log2_weight_denom;
+    int16_t chroma_log2_weight_denom;
+
+    int16_t luma_weight_l0[16];
+    int16_t chroma_weight_l0[16][2];
+    int16_t chroma_weight_l1[16][2];
+    int16_t luma_weight_l1[16];
+
+    int16_t luma_offset_l0[16];
+    int16_t chroma_offset_l0[16][2];
+
+    int16_t luma_offset_l1[16];
+    int16_t chroma_offset_l1[16][2];
+
+    int    slice_ctb_addr_rs;
+} SliceHeader;
+
+typedef struct CodingTree {
+    int depth; ///< ctDepth
+} CodingTree;
+
+typedef struct CodingUnit {
+    int x;
+    int y;
+
+    enum PredMode pred_mode; ///< PredMode
+    enum PartMode part_mode; ///< PartMode
+
+    uint8_t rqt_root_cbf;
+
+    uint8_t pcm_flag;
+
+    // Inferred parameters
+    uint8_t intra_split_flag; ///< IntraSplitFlag
+    uint8_t max_trafo_depth; ///< MaxTrafoDepth
+    uint8_t cu_transquant_bypass_flag;
+} CodingUnit;
+
+typedef struct Mv {
+    int16_t x;     ///< horizontal component of motion vector
+    int16_t y;     ///< vertical component of motion vector
+} Mv;
+
+typedef struct MvField {
+    Mv  mv[2];
+    int8_t ref_idx[2];
+    int8_t pred_flag[2];
+    uint8_t is_intra;
+} MvField;
+
+typedef struct NeighbourAvailable {
+    int cand_bottom_left;
+    int cand_left;
+    int cand_up;
+    int cand_up_left;
+    int cand_up_right;
+    int cand_up_right_sap;
+} NeighbourAvailable;
+
+typedef struct PredictionUnit {
+    int mpm_idx;
+    int rem_intra_luma_pred_mode;
+    uint8_t intra_pred_mode[4];
+    Mv mvd;
+    uint8_t merge_flag;
+    uint8_t intra_pred_mode_c;
+} PredictionUnit;
+
+typedef struct TransformTree {
+    uint8_t cbf_cb[MAX_TRANSFORM_DEPTH][MAX_CU_SIZE * MAX_CU_SIZE];
+    uint8_t cbf_cr[MAX_TRANSFORM_DEPTH][MAX_CU_SIZE * MAX_CU_SIZE];
+    uint8_t cbf_luma;
+
+    // Inferred parameters
+    uint8_t inter_split_flag;
+} TransformTree;
+
+typedef struct TransformUnit {
+    int cu_qp_delta;
+
+    // Inferred parameters;
+    int cur_intra_pred_mode;
+    uint8_t is_cu_qp_delta_coded;
+} TransformUnit;
+
+typedef struct SAOParams {
+    int offset_abs[3][4]; ///< sao_offset_abs
+    int offset_sign[3][4]; ///< sao_offset_sign
+
+    int band_position[3]; ///< sao_band_position
+
+    int eo_class[3]; ///< sao_eo_class
+
+    int offset_val[3][5]; ///<SaoOffsetVal
+
+    uint8_t type_idx[3]; ///< sao_type_idx
+} SAOParams;
+
+typedef struct DBParams {
+    int beta_offset;
+    int tc_offset;
+} DBParams;
+
+#define HEVC_FRAME_FLAG_OUTPUT    (1 << 0)
+#define HEVC_FRAME_FLAG_SHORT_REF (1 << 1)
+#define HEVC_FRAME_FLAG_LONG_REF  (1 << 2)
+
+typedef struct HEVCFrame {
+    AVFrame *frame;
+    MvField *tab_mvf;
+    RefPicList *refPicList;
+    RefPicListTab **rpl_tab;
+    int ctb_count;
+    int poc;
+    struct HEVCFrame *collocated_ref;
+
+    HEVCWindow window;
+
+    AVBufferRef *tab_mvf_buf;
+    AVBufferRef *rpl_tab_buf;
+    AVBufferRef *rpl_buf;
+
+    /**
+     * A sequence counter, so that old frames are output first
+     * after a POC reset
+     */
+    uint16_t sequence;
+
+    /**
+     * A combination of HEVC_FRAME_FLAG_*
+     */
+    uint8_t flags;
+} HEVCFrame;
+
+typedef struct HEVCNAL {
+    uint8_t *rbsp_buffer;
+    int rbsp_buffer_size;
+
+    int size;
+    const uint8_t *data;
+} HEVCNAL;
+
+typedef struct HEVCLocalContext {
+    DECLARE_ALIGNED(16, int16_t, mc_buffer[(MAX_PB_SIZE + 7) * MAX_PB_SIZE]);
+    uint8_t cabac_state[HEVC_CONTEXTS];
+
+    uint8_t first_qp_group;
+
+    GetBitContext gb;
+    CABACContext cc;
+    TransformTree tt;
+
+    int8_t qp_y;
+    int8_t curr_qp_y;
+
+    TransformUnit tu;
+
+    uint8_t ctb_left_flag;
+    uint8_t ctb_up_flag;
+    uint8_t ctb_up_right_flag;
+    uint8_t ctb_up_left_flag;
+    int     start_of_tiles_x;
+    int     end_of_tiles_x;
+    int     end_of_tiles_y;
+    uint8_t *edge_emu_buffer;
+    int      edge_emu_buffer_size;
+    CodingTree ct;
+    CodingUnit cu;
+    PredictionUnit pu;
+    NeighbourAvailable na;
+
+    uint8_t slice_or_tiles_left_boundary;
+    uint8_t slice_or_tiles_up_boundary;
+} HEVCLocalContext;
+
+typedef struct HEVCContext {
+    const AVClass *c;  // needed by private avoptions
+    AVCodecContext      *avctx;
+
+    struct HEVCContext  *sList[MAX_NB_THREADS];
+
+    HEVCLocalContext    *HEVClcList[MAX_NB_THREADS];
+    HEVCLocalContext    *HEVClc;
+
+    uint8_t             threads_type;
+    uint8_t             threads_number;
+
+    int                 width;
+    int                 height;
+
+    uint8_t *cabac_state;
+
+    /** 1 if the independent slice segment header was successfully parsed */
+    uint8_t slice_initialized;
+
+    AVFrame *frame;
+    AVFrame *sao_frame;
+    AVFrame *tmp_frame;
+    AVFrame *output_frame;
+    VPS *vps;
+    const HEVCSPS *sps;
+    HEVCPPS *pps;
+    VPS *vps_list[MAX_VPS_COUNT];
+    AVBufferRef *sps_list[MAX_SPS_COUNT];
+    AVBufferRef *pps_list[MAX_PPS_COUNT];
+
+    AVBufferPool *tab_mvf_pool;
+    AVBufferPool *rpl_tab_pool;
+
+    ///< candidate references for the current frame
+    RefPicList rps[5];
+
+    SliceHeader sh;
+    SAOParams *sao;
+    DBParams *deblock;
+    enum NALUnitType nal_unit_type;
+    int temporal_id;  ///< temporal_id_plus1 - 1
+    HEVCFrame *ref;
+    HEVCFrame DPB[32];
+    int poc;
+    int pocTid0;
+    int slice_idx; ///< number of the slice being currently decoded
+    int eos;       ///< current packet contains an EOS/EOB NAL
+    int max_ra;
+    int bs_width;
+    int bs_height;
+
+    int is_decoded;
+
+    int8_t *qp_y_tab;
+    uint8_t *split_cu_flag;
+    uint8_t *horizontal_bs;
+    uint8_t *vertical_bs;
+
+    int32_t *tab_slice_address;
+
+    //  CU
+    uint8_t *skip_flag;
+    uint8_t *tab_ct_depth;
+    // PU
+    uint8_t *tab_ipm;
+
+
+    uint8_t *cbf_luma; // cbf_luma of colocated TU
+    uint8_t *is_pcm;
+
+    // CTB-level flags affecting loop filter operation
+    uint8_t *filter_slice_edges;
+
+    /** used on BE to byteswap the lines for checksumming */
+    uint8_t *checksum_buf;
+    int      checksum_buf_size;
+
+    /**
+     * Sequence counters for decoded and output frames, so that old
+     * frames are output first after a POC reset
+     */
+    uint16_t seq_decode;
+    uint16_t seq_output;
+
+    int enable_parallel_tiles;
+    int wpp_err;
+    int skipped_bytes;
+    int *skipped_bytes_pos;
+    int skipped_bytes_pos_size;
+
+    int *skipped_bytes_nal;
+    int **skipped_bytes_pos_nal;
+    int *skipped_bytes_pos_size_nal;
+
+    uint8_t *data;
+
+    HEVCNAL *nals;
+    int nb_nals;
+    int nals_allocated;
+
+    // for checking the frame checksums
+    struct AVMD5 *md5_ctx;
+    uint8_t       md5[3][16];
+    uint8_t is_md5;
+
+    int context_initialized;
+    int is_nalff;         ///< this flag is != 0 if bitstream is encapsulated
+                          ///< as a format defined in 14496-15
+    int strict_def_disp_win;
+
+    int nal_length_size;  ///< Number of bytes used for nal length (1, 2 or 4)
+    int nuh_layer_id;
+
+} HEVCContext;
+
+typedef struct hevc_info{
+	const uint8_t *sps;
+	size_t sps_size;
+	int mwidth;
+	int mheight;
+};
+
+int check_size_in_buffer(unsigned char *p, int len);
+int check_size_in_buffer3(unsigned char *p, int len);
+
+int HEVC_decode_SPS(const uint8_t *buf,int size,struct hevc_info*info);
+
+
+int ff_hevc_extract_rbsp(HEVCContext *s, const uint8_t *src, int length,
+                         HEVCNAL *nal);
+
+int ff_hevc_decode_nal_vps(HEVCContext *s);
+int ff_hevc_decode_nal_sps(HEVCContext *s);
+int ff_hevc_decode_nal_pps(HEVCContext *s);
+int ff_hevc_decode_nal_sei(HEVCContext *s);
+
+/**
+ * Compute POC of the current frame and return it.
+ */
+int ff_hevc_compute_poc(HEVCContext *s, int poc_lsb);
+
+const uint8_t *avpriv_find_start_code(const uint8_t *p,
+                                      const uint8_t *end,
+                                      uint32_t *state);
+
+#endif // AVCODEC_HEVC_H
diff --git a/amffmpeg/libavcodec/hevc_parser.c b/amffmpeg/libavcodec/hevc_parser.c
new file mode 100644
index 0000000..62990f8
--- /dev/null
+++ b/amffmpeg/libavcodec/hevc_parser.c
@@ -0,0 +1,362 @@
+/*
+ * HEVC Annex B format parser
+ *
+ * Copyright (C) 2012 - 2013 Guillaume Martres
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include "libavutil/common.h"
+#include "parser.h"
+#include "hevc.h"
+#include "golomb.h"
+
+#define START_CODE 0x000001 ///< start_code_prefix_one_3bytes
+
+typedef struct HEVCParseContext {
+    HEVCContext  h;
+    ParseContext pc;
+} HEVCParseContext;
+
+/**
+ * Find the end of the current frame in the bitstream.
+ * @return the position of the first byte of the next frame, or END_NOT_FOUND
+ */
+static int hevc_find_frame_end(AVCodecParserContext *s, const uint8_t *buf, int buf_size)
+{
+    int i;
+    ParseContext *pc = &((HEVCParseContext *)s->priv_data)->pc;
+
+    for (i = 0; i < buf_size; i++) {
+        int nut;
+
+        pc->state64 = (pc->state64 << 8) | buf[i];
+
+        if (((pc->state64 >> 3 * 8) & 0xFFFFFF) != START_CODE)
+            continue;
+
+        nut = (pc->state64 >> 2 * 8 + 1) & 0x3F;
+        // Beginning of access unit
+        if ((nut >= NAL_VPS && nut <= NAL_AUD) || nut == NAL_SEI_PREFIX ||
+            (nut >= 41 && nut <= 44) || (nut >= 48 && nut <= 55)) {
+            if (pc->frame_start_found) {
+                pc->frame_start_found = 0;
+                return i - 5;
+            }
+        } else if (nut <= NAL_RASL_R ||
+                   (nut >= NAL_BLA_W_LP && nut <= NAL_CRA_NUT)) {
+            int first_slice_segment_in_pic_flag = buf[i] >> 7;
+            if (first_slice_segment_in_pic_flag) {
+                if (!pc->frame_start_found) {
+                    pc->frame_start_found = 1;
+                } else { // First slice of next frame found
+                    pc->frame_start_found = 0;
+                    return i - 5;
+                }
+            }
+        }
+    }
+
+    return END_NOT_FOUND;
+}
+
+/**
+ * Parse NAL units of found picture and decode some basic information.
+ *
+ * @param s parser context.
+ * @param avctx codec context.
+ * @param buf buffer with field/frame data.
+ * @param buf_size size of the buffer.
+ */
+static inline int parse_nal_units(AVCodecParserContext *s,
+                                  AVCodecContext *avctx,
+                                  const uint8_t *buf, int buf_size)
+{
+    HEVCContext   *h  = &((HEVCParseContext *)s->priv_data)->h;
+    GetBitContext *gb = &h->HEVClc->gb;
+    SliceHeader   *sh = &h->sh;
+    const uint8_t *buf_end = buf + buf_size;
+    int state = -1, i;
+    HEVCNAL *nal;
+
+    /* set some sane default values */
+    s->pict_type         = AV_PICTURE_TYPE_I;
+    s->key_frame         = 0;
+
+    h->avctx = avctx;
+
+    if (!buf_size)
+        return 0;
+
+    if (h->nals_allocated < 1) {
+        HEVCNAL *tmp = av_realloc_array(h->nals, 1, sizeof(*tmp));
+        if (!tmp)
+            return AVERROR(ENOMEM);
+        h->nals = tmp;
+        memset(h->nals, 0, sizeof(*tmp));
+        h->nals_allocated = 1;
+    }
+
+    nal = &h->nals[0];
+
+    for (;;) {
+        int src_length, consumed;
+        if (s->flags & PARSER_FLAG_COMPLETE_FRAMES) {
+            unsigned char *p = buf;
+            if (check_size_in_buffer(buf, buf_end -buf)) {
+                buf += 4;
+                goto PASS;
+            } else if (check_size_in_buffer3(buf, buf_end -buf)) {
+                buf += 3;
+                goto PASS;
+            }
+        }
+        buf = avpriv_find_start_code(buf, buf_end, &state);
+        if (--buf + 2 >= buf_end)
+            break;
+PASS:
+        src_length = buf_end - buf;
+
+        h->nal_unit_type = (*buf >> 1) & 0x3f;
+        h->temporal_id   = (*(buf + 1) & 0x07) - 1;
+        if (h->nal_unit_type <= NAL_CRA_NUT) {
+            // Do not walk the whole buffer just to decode slice segment header
+            if (src_length > 20)
+                src_length = 20;
+        }
+
+        consumed = ff_hevc_extract_rbsp(h, buf, src_length, nal);
+        if (consumed < 0)
+            return consumed;
+
+        init_get_bits8(gb, nal->data + 2, nal->size);
+        switch (h->nal_unit_type) {
+        case NAL_VPS:
+            ff_hevc_decode_nal_vps(h);
+            break;
+        case NAL_SPS:
+            ff_hevc_decode_nal_sps(h);
+            HEVCSPS *sps = (HEVCSPS*)h->sps_list[0]->data;
+            avctx->width = sps->width;
+            avctx->height = sps->height;
+            avctx->bit_depth = sps->bit_depth;
+            if(sps->long_term_ref_pics_present_flag==1 && sps->num_long_term_ref_pics_sps>0) {
+                avctx->long_term_ref_pic = 1;
+            }
+            break;
+        case NAL_PPS:
+            ff_hevc_decode_nal_pps(h);
+            break;
+        case NAL_SEI_PREFIX:
+        case NAL_SEI_SUFFIX:
+            ff_hevc_decode_nal_sei(h);
+            break;
+        case NAL_TRAIL_N:
+        case NAL_TRAIL_R:
+        case NAL_TSA_N:
+        case NAL_TSA_R:
+        case NAL_STSA_N:
+        case NAL_STSA_R:
+        case NAL_RADL_N:
+        case NAL_RADL_R:
+        case NAL_RASL_N:
+        case NAL_RASL_R:
+        case NAL_BLA_W_LP:
+        case NAL_BLA_W_RADL:
+        case NAL_BLA_N_LP:
+        case NAL_IDR_W_RADL:
+        case NAL_IDR_N_LP:
+        case NAL_CRA_NUT:
+            sh->first_slice_in_pic_flag = get_bits1(gb);
+
+            if (h->nal_unit_type >= 16 && h->nal_unit_type <= 23) {
+                s->key_frame = 1;
+                sh->no_output_of_prior_pics_flag = get_bits1(gb);
+            }
+
+            sh->pps_id = get_ue_golomb(gb);
+            if (sh->pps_id >= MAX_PPS_COUNT || !h->pps_list[sh->pps_id]) {
+                //av_log(h->avctx, AV_LOG_DEBUG, "PPS id out of range: %d\n", sh->pps_id);
+                return AVERROR_INVALIDDATA;
+            }
+            h->pps = (HEVCPPS*)h->pps_list[sh->pps_id]->data;
+
+            if (h->pps->sps_id >= MAX_SPS_COUNT || !h->sps_list[h->pps->sps_id]) {
+                //av_log(h->avctx, AV_LOG_DEBUG, "SPS id out of range: %d\n", h->pps->sps_id);
+                return AVERROR_INVALIDDATA;
+            }
+            if (h->sps != (HEVCSPS*)h->sps_list[h->pps->sps_id]->data) {
+                h->sps = (HEVCSPS*)h->sps_list[h->pps->sps_id]->data;
+                h->vps = h->vps_list[h->sps->vps_id];
+            }
+
+            if (!sh->first_slice_in_pic_flag) {
+                int slice_address_length;
+
+                if (h->pps->dependent_slice_segments_enabled_flag)
+                    sh->dependent_slice_segment_flag = get_bits1(gb);
+                else
+                    sh->dependent_slice_segment_flag = 0;
+
+                slice_address_length = av_ceil_log2_c(h->sps->ctb_width *
+                                                      h->sps->ctb_height);
+                sh->slice_segment_addr = get_bits(gb, slice_address_length);
+                if (sh->slice_segment_addr >= h->sps->ctb_width * h->sps->ctb_height) {
+                    av_log(h->avctx, AV_LOG_ERROR, "Invalid slice segment address: %u.\n",
+                           sh->slice_segment_addr);
+                    return AVERROR_INVALIDDATA;
+                }
+            } else
+                sh->dependent_slice_segment_flag = 0;
+
+            if (sh->dependent_slice_segment_flag)
+                break;
+
+            for (i = 0; i < h->pps->num_extra_slice_header_bits; i++)
+                skip_bits(gb, 1); // slice_reserved_undetermined_flag[]
+
+            sh->slice_type = get_ue_golomb(gb);
+            if (!(sh->slice_type == I_SLICE || sh->slice_type == P_SLICE ||
+                  sh->slice_type == B_SLICE)) {
+                av_log(h->avctx, AV_LOG_ERROR, "Unknown slice type: %d.\n",
+                       sh->slice_type);
+                return AVERROR_INVALIDDATA;
+            }
+            s->pict_type = sh->slice_type == B_SLICE ? AV_PICTURE_TYPE_B :
+                           sh->slice_type == P_SLICE ? AV_PICTURE_TYPE_P :
+                                                       AV_PICTURE_TYPE_I;
+
+            if (h->pps->output_flag_present_flag)
+                sh->pic_output_flag = get_bits1(gb);
+
+            if (h->sps->separate_colour_plane_flag)
+                sh->colour_plane_id = get_bits(gb, 2);
+
+            if (!IS_IDR(h)) {
+                sh->pic_order_cnt_lsb = get_bits(gb, h->sps->log2_max_poc_lsb);
+                h->poc = ff_hevc_compute_poc(h, sh->pic_order_cnt_lsb);
+            } else
+                h->poc = 0;
+
+            if (h->temporal_id == 0 &&
+                h->nal_unit_type != NAL_TRAIL_N &&
+                h->nal_unit_type != NAL_TSA_N &&
+                h->nal_unit_type != NAL_STSA_N &&
+                h->nal_unit_type != NAL_RADL_N &&
+                h->nal_unit_type != NAL_RASL_N &&
+                h->nal_unit_type != NAL_RADL_R &&
+                h->nal_unit_type != NAL_RASL_R)
+                h->pocTid0 = h->poc;
+
+            return 0; /* no need to evaluate the rest */
+        }
+        buf += consumed;
+    }
+    /* didn't find a picture! */
+    av_log(h->avctx, AV_LOG_ERROR, "missing picture in access unit\n");
+    return -1;
+}
+
+static int hevc_parse(AVCodecParserContext *s,
+                      AVCodecContext *avctx,
+                      const uint8_t **poutbuf, int *poutbuf_size,
+                      const uint8_t *buf, int buf_size)
+{
+    int next;
+    ParseContext *pc = &((HEVCParseContext *)s->priv_data)->pc;
+
+    if (s->flags & PARSER_FLAG_COMPLETE_FRAMES) {
+        next = buf_size;
+    } else {
+        next = hevc_find_frame_end(s, buf, buf_size);
+        if (ff_combine_frame(pc, next, &buf, &buf_size) < 0) {
+            *poutbuf = NULL;
+            *poutbuf_size = 0;
+            return buf_size;
+        }
+    }
+
+    parse_nal_units(s, avctx, buf, buf_size);
+
+    *poutbuf = buf;
+    *poutbuf_size = buf_size;
+    return next;
+}
+
+// Split after the parameter sets at the beginning of the stream if they exist.
+static int hevc_split(AVCodecContext *avctx, const uint8_t *buf, int buf_size)
+{
+    int i;
+    uint32_t state = -1;
+    int has_ps = 0;
+
+    for (i = 0; i < buf_size; i++) {
+        state = (state << 8) | buf[i];
+        if (((state >> 8) & 0xFFFFFF) == START_CODE) {
+            int nut = (state >> 1) & 0x3F;
+            if (nut >= NAL_VPS && nut <= NAL_PPS) {
+                has_ps = 1;
+            } else if (has_ps) {
+                return i - 3;
+            } else { // no parameter set at the beginning of the stream
+                return 0;
+            }
+        }
+    }
+    return 0;
+}
+
+static int hevc_init(AVCodecParserContext *s)
+{
+    HEVCContext  *h  = &((HEVCParseContext *)s->priv_data)->h;
+    h->HEVClc = av_mallocz(sizeof(HEVCLocalContext));
+    h->skipped_bytes_pos_size = INT_MAX;
+
+    return 0;
+}
+
+static void hevc_close(AVCodecParserContext *s)
+{
+    int i;
+    HEVCContext  *h  = &((HEVCParseContext *)s->priv_data)->h;
+    ParseContext *pc = &((HEVCParseContext *)s->priv_data)->pc;
+
+    av_freep(&h->skipped_bytes_pos);
+    av_freep(&h->HEVClc);
+    av_freep(&pc->buffer);
+
+    for (i = 0; i < FF_ARRAY_ELEMS(h->vps_list); i++)
+        av_freep(&h->vps_list[i]);
+    for (i = 0; i < FF_ARRAY_ELEMS(h->sps_list); i++)
+        av_buffer_unref(&h->sps_list[i]);
+    for (i = 0; i < FF_ARRAY_ELEMS(h->pps_list); i++)
+        av_buffer_unref(&h->pps_list[i]);
+
+    for (i = 0; i < h->nals_allocated; i++)
+        av_freep(&h->nals[i].rbsp_buffer);
+    av_freep(&h->nals);
+    h->nals_allocated = 0;
+}
+
+AVCodecParser ff_hevc_parser = {
+    .codec_ids      = { CODEC_ID_HEVC },
+    .priv_data_size = sizeof(HEVCParseContext),
+    .parser_init    = hevc_init,
+    .parser_parse   = hevc_parse,
+    .parser_close   = hevc_close,
+    .split          = hevc_split,
+};
diff --git a/amffmpeg/libavformat/Makefile b/amffmpeg/libavformat/Makefile
index d6bb7bf..d3cbac2 100755
--- a/amffmpeg/libavformat/Makefile
+++ b/amffmpeg/libavformat/Makefile
@@ -113,6 +113,7 @@ OBJS-$(CONFIG_H263_DEMUXER)              += h263dec.o rawdec.o
 OBJS-$(CONFIG_H263_MUXER)                += rawenc.o
 OBJS-$(CONFIG_H264_DEMUXER)              += h264dec.o rawdec.o
 OBJS-$(CONFIG_H264_MUXER)                += rawenc.o
+OBJS-$(CONFIG_HEVC_DEMUXER)              += hevcdec.o rawdec.o
 OBJS-$(CONFIG_IDCIN_DEMUXER)             += idcin.o
 OBJS-$(CONFIG_IFF_DEMUXER)               += iff.o
 OBJS-$(CONFIG_IMAGE2_DEMUXER)            += img2.o
diff --git a/amffmpeg/libavformat/allformats.c b/amffmpeg/libavformat/allformats.c
index 66e1eac..9223361 100755
--- a/amffmpeg/libavformat/allformats.c
+++ b/amffmpeg/libavformat/allformats.c
@@ -129,6 +129,7 @@ void av_register_all(void)
     REGISTER_MUXDEMUX (H261, h261);
     REGISTER_MUXDEMUX (H263, h263);
     REGISTER_MUXDEMUX (H264, h264);
+    REGISTER_DEMUXER (HEVC, hevc);
     REGISTER_DEMUXER  (IDCIN, idcin);
     REGISTER_DEMUXER  (IFF, iff);
     REGISTER_MUXDEMUX (IMAGE2, image2);
diff --git a/amffmpeg/libavformat/avformat.h b/amffmpeg/libavformat/avformat.h
index 873e3d1..8916799 100755
--- a/amffmpeg/libavformat/avformat.h
+++ b/amffmpeg/libavformat/avformat.h
@@ -924,6 +924,10 @@ typedef struct AVFormatContext {
     /* added by Z.C for DRM content */
     int drmcontent;
 	int skip_extradata;
+
+    // insert vps/sps/pps before stream
+    int ts_hevc_csd_valid;
+    uint8_t ts_hevc_csd_packet[188];
 } AVFormatContext;
 
 typedef struct AVPacketList {
diff --git a/amffmpeg/libavformat/hevcdec.c b/amffmpeg/libavformat/hevcdec.c
new file mode 100644
index 0000000..a59613a
--- /dev/null
+++ b/amffmpeg/libavformat/hevcdec.c
@@ -0,0 +1,90 @@
+/*
+ * RAW HEVC video demuxer
+ * Copyright (c) 2013 Dirk Farin <dirk.farin@gmail.com>
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include "avformat.h"
+#include "rawdec.h"
+
+enum NALUnitType {
+    NAL_TRAIL_N    = 0,
+    NAL_TRAIL_R    = 1,
+    NAL_TSA_N      = 2,
+    NAL_TSA_R      = 3,
+    NAL_STSA_N     = 4,
+    NAL_STSA_R     = 5,
+    NAL_RADL_N     = 6,
+    NAL_RADL_R     = 7,
+    NAL_RASL_N     = 8,
+    NAL_RASL_R     = 9,
+    NAL_BLA_W_LP   = 16,
+    NAL_BLA_W_RADL = 17,
+    NAL_BLA_N_LP   = 18,
+    NAL_IDR_W_RADL = 19,
+    NAL_IDR_N_LP   = 20,
+    NAL_CRA_NUT    = 21,
+    NAL_VPS        = 32,
+    NAL_SPS        = 33,
+    NAL_PPS        = 34,
+    NAL_AUD        = 35,
+    NAL_EOS_NUT    = 36,
+    NAL_EOB_NUT    = 37,
+    NAL_FD_NUT     = 38,
+    NAL_SEI_PREFIX = 39,
+    NAL_SEI_SUFFIX = 40,
+};
+
+static int hevc_probe(AVProbeData *p)
+{
+    uint32_t code = -1;
+    int vps = 0, sps = 0, pps = 0, irap = 0;
+    int i;
+
+    for (i = 0; i < p->buf_size - 1; i++) {
+        code = (code << 8) + p->buf[i];
+        if ((code & 0xffffff00) == 0x100) {
+            uint8_t nal2 = p->buf[i + 1];
+            int type = (code & 0x7E) >> 1;
+
+            if (code & 0x81) // forbidden and reserved zero bits
+                return 0;
+
+            if (nal2 & 0xf8) // reserved zero
+                return 0;
+
+            switch (type) {
+            case NAL_VPS:        vps++;  break;
+            case NAL_SPS:        sps++;  break;
+            case NAL_PPS:        pps++;  break;
+            case NAL_BLA_N_LP:
+            case NAL_BLA_W_LP:
+            case NAL_BLA_W_RADL:
+            case NAL_CRA_NUT:
+            case NAL_IDR_N_LP:
+            case NAL_IDR_W_RADL: irap++; break;
+            }
+        }
+    }
+
+    if (vps && sps && pps && irap)
+        return AVPROBE_SCORE_MAX/2 + 1; // 1 more than .mpg
+    return 0;
+}
+
+FF_DEF_RAWVIDEO_DEMUXER(hevc, "raw HEVC video", hevc_probe, "hevc,h265,265", CODEC_ID_HEVC)
diff --git a/amplayer/player/player_av.c b/amplayer/player/player_av.c
index c9f5056..61a4fc9 100755
--- a/amplayer/player/player_av.c
+++ b/amplayer/player/player_av.c
@@ -51,6 +51,7 @@ static const media_type media_array[] = {
     {"dts", DTS_FILE, STREAM_AUDIO},
     {"flac", FLAC_FILE, STREAM_AUDIO},
     {"h264", H264_FILE, STREAM_VIDEO},
+    {"hevc", HEVC_FILE, STREAM_VIDEO},
     {"cavs", AVS_FILE, STREAM_VIDEO},
     {"mpegvideo", M2V_FILE, STREAM_VIDEO},
     {"p2p", P2P_FILE, STREAM_ES},
@@ -207,6 +208,10 @@ vformat_t video_type_convert(enum CodecID id)
         format = VFORMAT_H264MVC;
         break;
 
+    case CODEC_ID_HEVC:
+        format = VFORMAT_HEVC;
+        break;
+
     case CODEC_ID_MJPEG:
         format = VFORMAT_MJPEG;
         break;
@@ -319,6 +324,18 @@ vdec_type_t video_codec_type_convert(unsigned int id)
         dec_type = VIDEO_DEC_FORMAT_H264;
         break;
 
+    case CODEC_TAG_HEVC:
+    case CODEC_TAG_hev1:
+    case CODEC_TAG_hvc1:
+        log_print("VIDEO_TYPE_HEVC\n");
+        dec_type = VIDEO_DEC_FORMAT_HEVC;
+        break;
+
+    case CODEC_ID_HEVC:
+        log_print("[video_codec_type_convert]VIDEO_DEC_FORMAT_HEVC(0x%x)\n", id);
+        dec_type = VIDEO_DEC_FORMAT_HEVC;
+        break;
+
     case CODEC_ID_RV30:
         log_print("[video_codec_type_convert]VIDEO_DEC_FORMAT_REAL_8(0x%x)\n", id);
         dec_type = VIDEO_DEC_FORMAT_REAL_8;
@@ -2083,7 +2100,14 @@ int set_header_info(play_para_t *para)
                         return ret;
                     }
                 }
-
+            } else if(para->vstream_info.video_format == VFORMAT_HEVC
+                 && para->file_type != STREAM_FILE) {
+                if (!(para->p_pkt->avpkt->flags & AV_PKT_FLAG_ISDECRYPTINFO)){
+                    ret = hevc_update_frame_header(pkt);
+                    if (ret != PLAYER_SUCCESS) {
+                        return ret;
+                    }
+                }
             } else if (para->vstream_info.video_format == VFORMAT_MPEG4) {
                 if (para->vstream_info.video_codec_type == VIDEO_DEC_FORMAT_MPEG4_3) {
                     return divx3_prefix(pkt);
diff --git a/amplayer/player/player_ctrl.c b/amplayer/player/player_ctrl.c
index d33f1ed..ba20bd3 100755
--- a/amplayer/player/player_ctrl.c
+++ b/amplayer/player/player_ctrl.c
@@ -1540,7 +1540,10 @@ static char* player_vformat2str(vformat_t value)
             
         case VFORMAT_H264:
             return "VFORMAT_H264";
-            
+
+        case VFORMAT_HEVC:
+            return "VFORMAT_HEVC";
+
         case VFORMAT_MJPEG:
             return "VFORMAT_MJPEG";
             
diff --git a/amplayer/player/player_ffmpeg_ctrl.c b/amplayer/player/player_ffmpeg_ctrl.c
index 5ab6915..8a337d4 100755
--- a/amplayer/player/player_ffmpeg_ctrl.c
+++ b/amplayer/player/player_ffmpeg_ctrl.c
@@ -200,6 +200,9 @@ int ffmpeg_parse_file_type(play_para_t *am_p, player_file_type_t *type)
         int matroska_flag = 0;
         int vpx_flag = 0;
         int flv_flag = 0;
+        int hevc_flag = 0;
+        int wmv2_flag = 0;
+        int rm_flag = 0;
 
         type->fmt_string = pFCtx->iformat->name;
         if (!strcmp(type->fmt_string, "matroska,webm")) {
@@ -208,6 +211,13 @@ int ffmpeg_parse_file_type(play_para_t *am_p, player_file_type_t *type)
         if (!strcmp(type->fmt_string, "flv")) {
             flv_flag = 1;
         }
+        if (!strcmp(type->fmt_string, "hevc")) { // need to process h265 raw file
+            if(am_p->vdec_profile.hevc_para.exist) {
+                memset(format_string, 0, sizeof(format_string));
+                sprintf(format_string, "%s","hevcHW");
+                type->fmt_string = format_string;
+            }
+        }
 
         for (i = 0; i < pFCtx->nb_streams; i++) {
             AVStream *st = pFCtx->streams[i];
@@ -222,6 +232,15 @@ int ffmpeg_parse_file_type(play_para_t *am_p, player_file_type_t *type)
                         vpx_flag = 1;
                     }
                 }
+                if(st->codec->codec_id == CODEC_ID_HEVC) {
+                    if(!am_p->vdec_profile.hevc_para.exist) {
+                        if(hevc_flag == 0) {
+                            sprintf(vpx_string, "%s", "hevc");
+                            hevc_flag = 1;
+                        }
+                        log_print("Find no HW h265 decoder, need to use SW h265 decoder!\n");
+                    }
+                }
                 type->video_tracks++;
             } else if (st->codec->codec_type == CODEC_TYPE_AUDIO) {
                 type->audio_tracks++;
@@ -261,8 +280,8 @@ int ffmpeg_parse_file_type(play_para_t *am_p, player_file_type_t *type)
 			  }			  
 		 }
 	   //-----------------------------------------------------
-        // special process for webm/vpx, flv/vp6
-        if (matroska_flag || flv_flag || vpx_flag) {
+        // special process for webm/vpx, flv/vp6, hevc/h.265
+        if (matroska_flag || flv_flag || vpx_flag || hevc_flag || wmv2_flag || rm_flag) {
             int length = 0;
 
             memset(format_string, 0, sizeof(format_string));
@@ -273,7 +292,7 @@ int ffmpeg_parse_file_type(play_para_t *am_p, player_file_type_t *type)
                 length = sprintf(format_string, "%s", type->fmt_string);
             }
 
-            if (vpx_flag == 1) {
+            if (vpx_flag == 1 || hevc_flag == 1 || wmv2_flag == 1 || rm_flag == 1) {
                 sprintf(&format_string[length], ",%s", vpx_string);
                 memset(vpx_string, 0, sizeof(vpx_string));
             }
-- 
1.9.1

